import json
import os

# 保存先ディレクトリ
OUTPUT_DIR = "."
INDEX_FILE = "index.json"

# ==========================================
# Vol.102 新規問題データ定義
# ==========================================

# 1. 第1章 一般 (ch1_general_vol102.json)
q1_gen = [
    {
        "id": "Q1-GEN-V102-01",
        "chapter": "第1章",
        "level": "K3",
        "category": "一般",
        "style": "シナリオ",
        "type": "単一選択",
        "question": "【適用】テストモニタリングとコントロール。\nテスト実行の進捗は計画通り（オンスケジュール）だが、発見された欠陥の数が過去の類似プロジェクトと比較して著しく少ない（欠陥密度が低い）。\nこの状況下で、テストマネージャが疑うべきリスクと取るべきアクションはどれか。",
        "options": [
            "開発チームのスキル向上により品質が高まったと判断し、テスト期間を前倒しで終了して早期リリースを行うことで、コスト削減と市場投入の迅速化を図る（楽観的すぎる判断）",
            "テストケースの内容が薄い（欠陥を見つける能力が低い）、あるいはテスト環境の設定ミス（偽陰性）の可能性があるため、探索的テストを追加してクロスチェックを行う",
            "テスターが意図的にバグ報告をサボっている可能性があるため、バグ発見数にノルマを課し、ノルマ未達のメンバーにはペナルティを与えることで報告数を増やさせる（モラルの低下と偽装報告のリスク）",
            "欠陥密度が低いことはテスト工程の成功を意味するため、現状のテストプロセスに問題はないと結論付け、ステークホルダーに対して品質目標の完全達成を報告する（偽りの安心感）"
        ],
        "answer": [
            "テストケースの内容が薄い（欠陥を見つける能力が低い）、あるいはテスト環境の設定ミス（偽陰性）の可能性があるため、探索的テストを追加してクロスチェックを行う"
        ],
        "explanation": "【解説】\n「バグが出ない」＝「品質が良い」とは限りません。「殺虫剤のパラドックス」や環境不備を疑い、別の視点（探索的テストなど）で検証するのが定石です。",
        "tags": ["第1章", "一般", "シナリオ", "K3"]
    }
]

# 2. 第2章 金融 (ch2_finance_vol102.json)
q2_fin = [
    {
        "id": "Q2-FIN-V102-01",
        "chapter": "第2章",
        "level": "K3",
        "category": "金融",
        "style": "シナリオ",
        "type": "単一選択",
        "question": "【適用】PCI DSS（クレジットカード業界のセキュリティ基準）準拠システムのテストデータ準備。\nクレジットカード決済機能の結合テストを行うために、テスト用カード番号が必要となった。\nセキュリティとコンプライアンスの観点から最も適切なデータ準備方法はどれか。",
        "options": [
            "社内の従業員に協力を依頼し、実際に有効なクレジットカード番号とセキュリティコードを提供してもらうことで、本番決済ゲートウェイとの接続確認を確実に行う（本番データの不適切な利用）",
            "Luhnアルゴリズム（チェックデジット）に適合するが実在しない「テスト用カード番号」を使用するか、決済代行会社が提供するサンドボックス環境専用のダミー番号を使用する",
            "既存の顧客データベースからカード番号を抽出し、下4桁だけをマスキングして使用することで、個人情報を保護しつつデータのリアリティを確保する（カード番号自体の漏洩リスクが高い）",
            "カード番号の桁数（16桁）さえ合っていればテストには十分であるため、適当な16桁の数字（'1111111111111111'など）を使用する（チェックデジットエラーでテストにならない）"
        ],
        "answer": [
            "Luhnアルゴリズム（チェックデジット）に適合するが実在しない「テスト用カード番号」を使用するか、決済代行会社が提供するサンドボックス環境専用のダミー番号を使用する"
        ],
        "explanation": "【解説】\n実データの利用はPCI DSSで厳しく制限されます。Luhnチェックを通るダミー番号（テストカード）を使用するのが鉄則です。",
        "tags": ["第2章", "金融", "シナリオ", "K3"]
    }
]

# 3. 第1章 AWS (ch1_aws_vol102.json)
q1_aws = [
    {
        "id": "Q1-AWS-V102-01",
        "chapter": "第1章",
        "level": "K3",
        "category": "AWS",
        "style": "シナリオ",
        "type": "単一選択",
        "question": "【適用】AWSにおけるカオスエンジニアリング（Fault Injection）。\nマルチAZ構成のRDS（データベース）が、障害発生時に正しくフェイルオーバーすることを確認したい。\n本番環境に影響を与えずに、かつ本番に近い構成で検証するための最も推奨される方法はどれか。",
        "options": [
            "本番環境のプライマリDBインスタンスに対して、OSレベルで強制シャットダウンコマンドを実行し、アプリケーションがダウンタイムなしでスタンバイ機に切り替わるかを確認する（本番リスクが高すぎる）",
            "ステージング環境（本番相当の構成）において、RDSのマネージメントコンソールから「再起動（フェイルオーバー付き）」を実行し、アプリケーションの再接続挙動とダウンタイムを計測する",
            "AWSのデータセンターに物理的に侵入し、サーバーの電源ケーブルを抜くことで、物理障害発生時の挙動をリアルにシミュレーションする（犯罪および物理的に不可能）",
            "アプリケーション側のDB接続設定を書き換えて、存在しないIPアドレスに接続させ、タイムアウトエラーが発生した後にリトライ処理が動くことだけを確認する（DB側の切り替え挙動を確認できていない）"
        ],
        "answer": [
            "ステージング環境（本番相当の構成）において、RDSのマネージメントコンソールから「再起動（フェイルオーバー付き）」を実行し、アプリケーションの再接続挙動とダウンタイムを計測する"
        ],
        "explanation": "【解説】\nAWS RDSにはテスト用に「フェイルオーバーを伴う再起動」機能があります。これを利用するのが最も安全で確実です。本番での障害注入は、十分に成熟した組織以外は避けるべきです。",
        "tags": ["第1章", "AWS", "シナリオ", "K3"]
    }
]

# 4. 第3章 一般 (ch3_general_vol102.json)
q3_gen = [
    {
        "id": "Q3-GEN-V102-01",
        "chapter": "第3章",
        "level": "K3",
        "category": "一般",
        "style": "シナリオ",
        "type": "単一選択",
        "question": "【適用】欠陥のライフサイクル管理。\n開発者から「修正完了（Fixed）」として返ってきた欠陥レポートに対し、テスターが確認テスト（Re-test）を行ったところ、現象が再現し（直っておらず）、さらに別の新しいバグも発生していた。\nこの欠陥レポートのステータス遷移として正しい操作はどれか。",
        "options": [
            "開発者の修正が不完全であったため、ステータスを「Reopened（差し戻し）」にし、新たなバグについては別の新規レポート（New）を起票して関連付ける",
            "開発者を呼び出してその場で修正させ、直ったことを確認してからステータスを「Closed（完了）」に変更することで、これ以上の手戻りを防ぐ（プロセスの形骸化）",
            "修正完了ステータスのままにしておき、備考欄に「まだ直っていません」と追記して、開発者が気づくのを待つ（ワークフローの停滞）",
            "ステータスを「Closed」にしてレポートを閉じ、直っていない現象については全く新しい別のバグとして新規起票する（履歴が分断され、修正の経緯が追えなくなる）"
        ],
        "answer": [
            "開発者の修正が不完全であったため、ステータスを「Reopened（差し戻し）」にし、新たなバグについては別の新規レポート（New）を起票して関連付ける"
        ],
        "explanation": "【解説】\n直っていない場合は「Reopen」です。デグレード（新しいバグ）は、元のバグとは別の事象なので、混同せずに「新規起票」するのが原則です。",
        "tags": ["第3章", "一般", "シナリオ", "K3"]
    }
]

# 5. 第2章 一般 (ch2_general_vol102.json)
q2_gen = [
    {
        "id": "Q2-GEN-V102-01",
        "chapter": "第2章",
        "level": "K4",
        "category": "一般",
        "style": "シナリオ",
        "type": "単一選択",
        "question": "【分析】レビュー技法の選択。\n若手エンジニアが作成した詳細設計書に対し、ベテランエンジニアが「欠陥の検出」だけでなく「知識の伝達（教育）」や「将来の保守性向上」も目的としてレビューを行いたい。\n最も効果的なレビュータイプとその実施方法はどれか。",
        "options": [
            "モデレーターを立てた厳格な「インスペクション」を実施し、ドキュメントの不備を徹底的に指摘して点数をつけ、合格点に達するまで修正を繰り返させる（教育的効果よりも萎縮させるリスクがある）",
            "作成者が主導する「ウォークスルー」を実施し、シナリオに沿って設計意図を説明させながら、ベテランが質問やアドバイスを行う形式で相互理解を深める",
            "「パスアラウンド」形式で設計書をメール送付し、ベテランが空き時間にコメントを書いて返信することで、時間を拘束されずに効率的に指摘を行う（対話がないため教育効果が薄い）",
            "「アドホックレビュー」として、ベテランが気が向いた時に設計書を読み、見つけた間違いを口頭で指摘する（体系的な知識伝達にならない）"
        ],
        "answer": [
            "作成者が主導する「ウォークスルー」を実施し、シナリオに沿って設計意図を説明させながら、ベテランが質問やアドバイスを行う形式で相互理解を深める"
        ],
        "explanation": "【解説】\n「教育」や「知識共有」が目的の場合、対話型の「ウォークスルー」が最適です。インスペクションは欠陥検出には強力ですが、教育的な文脈では堅苦しすぎることがあります。",
        "tags": ["第2章", "一般", "シナリオ", "K4"]
    }
]

# ==========================================
# ファイル生成 & Index更新処理
# ==========================================
files_content = {
    "ch1_general_vol102.json": q1_gen,
    "ch2_finance_vol102.json": q2_fin,
    "ch1_aws_vol102.json": q1_aws,
    "ch3_general_vol102.json": q3_gen,
    "ch2_general_vol102.json": q2_gen
}

def generate_and_update():
    # 1. ファイル生成
    new_entries = []
    
    print("--- ファイル生成開始 ---")
    for filename, content in files_content.items():
        file_path = os.path.join(OUTPUT_DIR, filename)
        try:
            with open(file_path, 'w', encoding='utf-8') as f:
                json.dump(content, f, ensure_ascii=False, indent=2)
            print(f"作成: {filename}")
            
            # メタデータ抽出（Index用）
            first_q = content[0]
            entry = {
                "path": f"questions/{filename}", # アプリの仕様に合わせたパス
                "chapter": first_q.get("chapter", "不明"),
                "category": first_q.get("category", "不明"),
                "klevel": first_q.get("level", "K2"),
                "qCount": len(content)
            }
            new_entries.append(entry)
            
        except Exception as e:
            print(f"エラー作成中 {filename}: {e}")

    # 2. Index更新
    print("\n--- Index更新開始 ---")
    if not os.path.exists(INDEX_FILE):
        print(f"エラー: {INDEX_FILE} が見つかりません。")
        return

    try:
        with open(INDEX_FILE, 'r', encoding='utf-8') as f:
            index_data = json.load(f)
        
        existing_paths = {item.get("path") for item in index_data.get("chunks", [])}
        added_count = 0
        
        for entry in new_entries:
            if entry["path"] not in existing_paths:
                index_data["chunks"].append(entry)
                print(f"Index追加: {entry['path']}")
                added_count += 1
            else:
                print(f"Indexスキップ（登録済）: {entry['path']}")
        
        if added_count > 0:
            with open(INDEX_FILE, 'w', encoding='utf-8') as f:
                json.dump(index_data, f, ensure_ascii=False, indent=2)
            print(f"Index保存完了: {added_count}件追加")
        else:
            print("Index更新なし")

    except Exception as e:
        print(f"Index更新エラー: {e}")

if __name__ == "__main__":
    generate_and_update()