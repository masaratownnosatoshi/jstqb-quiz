import json
import os

# 保存先ディレクトリ
OUTPUT_DIR = "."
INDEX_FILE = "index.json"

# ==========================================
# Vol.113 新規問題データ定義
# ==========================================

# 1. 第1章 一般 (ch1_general_vol113.json)
q1_gen = [
    {
        "id": "Q1-GEN-V113-01",
        "chapter": "第1章",
        "level": "K3",
        "category": "一般",
        "style": "シナリオ",
        "type": "単一選択",
        "question": "【適用】テストの中断（サスペンド）基準の運用。\nテスト実行の初期段階で実施したスモークテストにおいて、主要機能の50%でブロッキングバグ（進行不可能な不具合）が発生した。\nテストマネージャが下すべき判断として、最も適切なものはどれか。",
        "options": [
            "テストスケジュールの遅延を防ぐために、不具合が出ている機能をスキップし、動く機能だけを選んでテストケースを消化し続ける（後半で手戻りが集中するリスク）",
            "テストの中断基準（Suspension Criteria）に該当すると判断し、テスト活動を一時停止してビルドを開発チームに差し戻し、修正版が届くまで待機する",
            "テストチームのスキル不足で進まない可能性があるため、ベテランのテスターを投入して、なんとか回避策を見つけながらテストを強行突破する（根本解決にならない）",
            "ブロッキングバグは重大な問題であるため、テストケースの合否判定をすべて「Fail」にしてテストを終了とし、不合格レポートを出してプロジェクトを中止する（改善の機会を与えていない）"
        ],
        "answer": [
            "テストの中断基準（Suspension Criteria）に該当すると判断し、テスト活動を一時停止してビルドを開発チームに差し戻し、修正版が届くまで待機する"
        ],
        "explanation": "【解説】\nテスト対象の品質が悪すぎてテストにならない場合、無理に進めるのはリソースの無駄です。「開始基準」や「中断基準」に従い、品質が基準に達するまで差し戻すのが正解です。",
        "tags": ["第1章", "一般", "シナリオ", "K3"]
    }
]

# 2. 第2章 一般 (ch2_general_vol113.json)
q2_gen = [
    {
        "id": "Q2-GEN-V113-01",
        "chapter": "第2章",
        "level": "K4",
        "category": "一般",
        "style": "シナリオ",
        "type": "単一選択",
        "question": "【分析】ペアワイズ法（オールペア法）の限界。\n組み合わせテスト技法としてペアワイズ法を採用し、テストを実施したにも関わらず、市場で特定の組み合わせによるバグが流出してしまった。\nこのバグの原因として、ペアワイズ法の特性上、検出が困難だったと考えられる状況はどれか。",
        "options": [
            "そのバグは「単一のパラメータ」の値が間違っているだけで発生する単純なバグであったが、ペアワイズ法では値の網羅性が低いため発見できなかった（ペアワイズは全パラメータの値を少なくとも1回は使用するため、単一バグは発見できる）",
            "そのバグは「3つ以上の特定のパラメータ」が特定の組み合わせになった時のみ発生するものであり、2因子間の網羅しか保証しないペアワイズ法ではテストケースに含まれていなかった",
            "ペアワイズ法は直交表と異なり、無効な組み合わせ（あり得ないケース）を排除できないため、テスト実行時にエラーになって検証できなかった（ペアワイズツールは制約条件で無効な組み合わせを排除可能）",
            "そのバグは境界値付近で発生するものであったが、ペアワイズ法は境界値分析と併用することが禁止されているため、代表値のみでテストしてしまった（併用は可能であり、手法の制約ではない）"
        ],
        "answer": [
            "そのバグは「3つ以上の特定のパラメータ」が特定の組み合わせになった時のみ発生するものであり、2因子間の網羅しか保証しないペアワイズ法ではテストケースに含まれていなかった"
        ],
        "explanation": "【解説】\nペアワイズ法は「任意の2つの因子の組み合わせ」を網羅しますが、3つ以上（トリプルなど）の特定の組み合わせで起きるバグは見逃すリスクがあります。",
        "tags": ["第2章", "一般", "シナリオ", "K4"]
    }
]

# 3. 第3章 一般 (ch3_general_vol113.json)
q3_gen = [
    {
        "id": "Q3-GEN-V113-01",
        "chapter": "第3章",
        "level": "K3",
        "category": "一般",
        "style": "シナリオ",
        "type": "単一選択",
        "question": "【適用】インスペクション（公式レビュー）におけるモデレーターの役割。\n設計書のインスペクション会議中、ある欠陥の指摘に対して参加者同士の議論が白熱し、修正方法について長時間の論争が始まってしまった。\n進行役であるモデレーターが取るべき行動はどれか。",
        "options": [
            "技術的な議論こそがレビューの価値を高めるため、時間の許す限りその場で徹底的に議論させ、全員が納得する解決策が出るまで見守る（レビュー会議の目的は「検出」であり「解決」ではない）",
            "議論が長引き会議の進行を妨げているため、その指摘を「課題（Open Issue）」として記録し、会議の場では解決策を決めずに次の指摘に進むよう誘導する",
            "欠陥を指摘したレビューアに対して「代替案がないなら批判するな」と注意し、対案が出せない指摘は却下して議事録から削除する（指摘のハードルを上げてしまう）",
            "モデレーター自身の技術的見解を述べてどちらが正しいかをその場で裁定し、強引に結論を出して会議を終わらせる（モデレーターの中立性に反する）"
        ],
        "answer": [
            "議論が長引き会議の進行を妨げているため、その指摘を「課題（Open Issue）」として記録し、会議の場では解決策を決めずに次の指摘に進むよう誘導する"
        ],
        "explanation": "【解説】\nインスペクションの会議目的は「欠陥の検出・共有」です。修正案の検討や議論は会議外で行うのが鉄則であり、モデレーターは進行管理（タイムキーパー）に徹します。",
        "tags": ["第3章", "一般", "シナリオ", "K3"]
    }
]

# 4. 第1章 AWS (ch1_aws_vol113.json)
q1_aws = [
    {
        "id": "Q1-AWS-V113-01",
        "chapter": "第1章",
        "level": "K3",
        "category": "AWS",
        "style": "シナリオ",
        "type": "単一選択",
        "question": "【適用】IAM権限の境界（Permissions Boundary）のテスト。\n開発者に対して「IAMユーザー作成権限」を委譲したいが、管理者権限（AdministratorAccess）を持つユーザーを勝手に作成されないように制限をかけたい。\nこの要件が満たされていることを検証するためのテストケースはどれか。",
        "options": [
            "開発者が作成したIAMユーザーに「AdministratorAccess」ポリシーをアタッチしようとした際に、Permissions Boundaryが設定されていない場合はエラーになることを確認する",
            "開発者のIAMユーザーでログインし、CloudTrailのログを確認して、自分の操作履歴が記録されているかを確認する（権限の制限とは関係ない）",
            "開発者に口頭で「管理者権限のユーザーは作らないように」と注意し、誓約書にサインしてもらう運用フローを確認する（システム的な強制力がない）",
            "ルートユーザー（Root User）でログインし、開発者が作成したユーザーを削除できることを確認する（管理者が削除できるのは当たり前であり、作成制限のテストではない）"
        ],
        "answer": [
            "開発者が作成したIAMユーザーに「AdministratorAccess」ポリシーをアタッチしようとした際に、Permissions Boundaryが設定されていない場合はエラーになることを確認する"
        ],
        "explanation": "【解説】\n権限移譲時の昇格防止には「Permissions Boundary」を使用します。テストでは「Boundaryを指定せずにユーザー作成やポリシーアタッチを行った場合に拒否されること」を確認します。",
        "tags": ["第1章", "AWS", "シナリオ", "K3"]
    }
]

# 5. 第2章 金融 (ch2_finance_vol113.json)
q2_fin = [
    {
        "id": "Q2-FIN-V113-01",
        "chapter": "第2章",
        "level": "K3",
        "category": "金融",
        "style": "シナリオ",
        "type": "単一選択",
        "question": "【適用】ノストロ口座（他行預け金口座）の照合テスト。\n銀行システムにおいて、自社の帳簿上の残高と、相手先銀行から送られてくる残高証明書（ステートメント）の内容を照合（Reconciliation）する機能をテストしたい。\nアンマッチ（不整合）の検出ロジックを検証するためのデータパターンはどれか。",
        "options": [
            "自社帳簿とステートメントの「金額」「日付」「通貨」がすべて一致する正常データのみを大量に流し込み、照合完了ステータスになることを確認する（不整合検出のテストにならない）",
            "「金額不一致」「片方のみに存在する取引（未達）」「日付ずれ」などの不整合パターンを含むデータを用意し、システムがそれらを「要調査（Exception）」として正しく検出し、リスト出力できることを確認する",
            "ステートメントのデータフォーマットをわざと壊したファイル（CSVのカラム不足など）を読み込ませ、システムがクラッシュしないことを確認する（フォーマットエラーのテストであり、業務ロジックのテストではない）",
            "差異が発生した場合に、相手先銀行のシステムに自動的にログインしてデータを修正する機能が動くことを確認する（他行のシステムを勝手に修正することはあり得ない）"
        ],
        "answer": [
            "「金額不一致」「片方のみに存在する取引（未達）」「日付ずれ」などの不整合パターンを含むデータを用意し、システムがそれらを「要調査（Exception）」として正しく検出し、リスト出力できることを確認する"
        ],
        "explanation": "【解説】\n銀行間照合（Reconciliation）の核心は「不整合の検出」です。金額違いや片側計上（未達）といった異常パターンを網羅的にテストする必要があります。",
        "tags": ["第2章", "金融", "シナリオ", "K3"]
    }
]

# ==========================================
# ファイル生成 & Index更新処理
# ==========================================
files_content = {
    "ch1_general_vol113.json": q1_gen,
    "ch2_general_vol113.json": q2_gen,
    "ch3_general_vol113.json": q3_gen,
    "ch1_aws_vol113.json": q1_aws,
    "ch2_finance_vol113.json": q2_fin
}

def generate_and_update():
    # 1. ファイル生成
    new_entries = []
    
    print("--- ファイル生成開始 ---")
    for filename, content in files_content.items():
        file_path = os.path.join(OUTPUT_DIR, filename)
        try:
            with open(file_path, 'w', encoding='utf-8') as f:
                json.dump(content, f, ensure_ascii=False, indent=2)
            print(f"作成: {filename}")
            
            # メタデータ抽出（Index用）
            first_q = content[0]
            entry = {
                "path": f"questions/{filename}", # アプリの仕様に合わせたパス
                "chapter": first_q.get("chapter", "不明"),
                "category": first_q.get("category", "不明"),
                "klevel": first_q.get("level", "K2"),
                "qCount": len(content)
            }
            new_entries.append(entry)
            
        except Exception as e:
            print(f"エラー作成中 {filename}: {e}")

    # 2. Index更新
    print("\n--- Index更新開始 ---")
    if not os.path.exists(INDEX_FILE):
        print(f"エラー: {INDEX_FILE} が見つかりません。")
        return

    try:
        with open(INDEX_FILE, 'r', encoding='utf-8') as f:
            index_data = json.load(f)
        
        existing_paths = {item.get("path") for item in index_data.get("chunks", [])}
        added_count = 0
        
        for entry in new_entries:
            if entry["path"] not in existing_paths:
                index_data["chunks"].append(entry)
                print(f"Index追加: {entry['path']}")
                added_count += 1
            else:
                print(f"Indexスキップ（登録済）: {entry['path']}")
        
        if added_count > 0:
            with open(INDEX_FILE, 'w', encoding='utf-8') as f:
                json.dump(index_data, f, ensure_ascii=False, indent=2)
            print(f"Index保存完了: {added_count}件追加")
        else:
            print("Index更新なし")

    except Exception as e:
        print(f"Index更新エラー: {e}")

if __name__ == "__main__":
    generate_and_update()