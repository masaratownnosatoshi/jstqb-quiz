import json
import os

# 保存先ディレクトリ
OUTPUT_DIR = "."
INDEX_FILE = "index.json"

# ==========================================
# Vol.115 新規問題データ定義
# ==========================================

# 1. 第3章 一般 (ch3_general_vol115.json)
q3_gen = [
    {
        "id": "Q3-GEN-V115-01",
        "chapter": "第3章",
        "level": "K3",
        "category": "一般",
        "style": "シナリオ",
        "type": "単一選択",
        "question": "【適用】テスト自動化の「メンテナンス地獄」からの脱却。\nUIの自動テストスクリプトが、画面レイアウトの軽微な変更のたびに大量に破損し、修正工数が手動テスト以上に膨らんでいる。\nこの状況を改善するための設計パターンとして、最も推奨されるものはどれか。",
        "options": [
            "自動テストツールを「キャプチャ＆リプレイ（記録・再生）」型のツールに変更し、コードを書かずに操作を記録する方式に切り替えることで、エンジニア以外のメンバーでも修正できるようにする（記録型はメンテナンス性がさらに低い）",
            "「ページオブジェクトパターン（Page Object Pattern）」を導入し、画面の要素特定ロジック（Selector）とテストシナリオを分離・カプセル化することで、画面変更の影響をページクラス内に限定する",
            "UIテストは壊れやすいため全面的に廃止し、すべてのテストをAPIレベルの結合テストに置き換えることで、画面変更の影響を受けないようにする（E2Eでのユーザー体験の検証ができなくなる）",
            "テストスクリプト内のIDやXPath指定を「絶対パス」で記述するように統一し、画面構造が変わっても要素を見失わないように厳密に定義する（構造変化に最も弱い書き方）"
        ],
        "answer": [
            "「ページオブジェクトパターン（Page Object Pattern）」を導入し、画面の要素特定ロジック（Selector）とテストシナリオを分離・カプセル化することで、画面変更の影響をページクラス内に限定する"
        ],
        "explanation": "【解説】\nUI自動化の保守性向上には「ページオブジェクトパターン」が定石です。画面操作の抽象化により、変更時の修正箇所を局所化できます。",
        "tags": ["第3章", "一般", "シナリオ", "K3"]
    }
]

# 2. 第2章 一般 (ch2_general_vol115.json)
q2_gen = [
    {
        "id": "Q2-GEN-V115-01",
        "chapter": "第2章",
        "level": "K3",
        "category": "一般",
        "style": "シナリオ",
        "type": "単一選択",
        "question": "【適用】レビューの効果向上（パースペクティブベースドリーディング）。\n設計書のレビューを行っているが、漫然と読んでいるためか、欠陥の見逃しが多い。\nレビューアに対して「特定の視点」を与え、欠陥検出の効率と網羅性を高めるための施策はどれか。",
        "options": [
            "レビューア全員に対して「誤字脱字がないか」「フォーマットが正しいか」を重点的にチェックさせ、ドキュメントの体裁を完璧にすることを最優先目標にする（本質的な欠陥が見つからない）",
            "「パースペクティブベースドリーディング（Perspective-Based Reading）」を採用し、レビューアごとに「テスト担当者視点（テスト可能か？）」「保守担当者視点（変更容易か？）」などの役割を割り当ててレビューさせる",
            "レビューアの人数を10名以上に増やし、多くの目でチェックすることで、「三人寄れば文殊の知恵」効果によって欠陥発見率を向上させる（責任の分散と調整コスト増大）",
            "レビュー時間を無制限に延長し、レビューアが納得するまで何時間でも読み込ませることで、集中力を極限まで高める（疲労による効率低下）"
        ],
        "answer": [
            "「パースペクティブベースドリーディング（Perspective-Based Reading）」を採用し、レビューアごとに「テスト担当者視点（テスト可能か？）」「保守担当者視点（変更容易か？）」などの役割を割り当ててレビューさせる"
        ],
        "explanation": "【解説】\n漫然としたレビューを防ぐには、PBR（Perspective-Based Reading）が有効です。特定の役割（視点）になりきることで、シナリオに基づいた深い検証が可能になります。",
        "tags": ["第2章", "一般", "シナリオ", "K3"]
    }
]

# 3. 第1章 AWS (ch1_aws_vol115.json)
q1_aws = [
    {
        "id": "Q1-AWS-V115-01",
        "chapter": "第1章",
        "level": "K3",
        "category": "AWS",
        "style": "シナリオ",
        "type": "単一選択",
        "question": "【適用】LambdaとRDSの接続構成テスト。\nVPC内のプライベートサブネットにあるRDSに対し、Lambda関数からアクセスする機能を実装した。\nタイムアウトエラーが発生して接続できない場合、最初に確認すべきネットワーク設定はどれか。",
        "options": [
            "Lambda関数に「VPC設定（サブネットとセキュリティグループ）」が正しく適用されており、かつRDSのセキュリティグループがLambdaからのインバウンド通信を許可しているかを確認する",
            "RDSをパブリックサブネットに移動し、「パブリックアクセス許可」を有効にすることで、インターネット経由でLambdaから接続できるように変更する（セキュリティリスクが高すぎる）",
            "Lambda関数のIAMロールに「AmazonRDSFullAccess」ポリシーをアタッチし、権限レベルでアクセスを許可する（ネットワーク到達性の問題はIAMでは解決しない）",
            "VPCにNAT Gatewayを作成し、Lambdaからのトラフィックを一度インターネットに出してから、グローバルIP経由でRDSに接続するようにルーティングを変更する（非効率かつ不適切な構成）"
        ],
        "answer": [
            "Lambda関数に「VPC設定（サブネットとセキュリティグループ）」が正しく適用されており、かつRDSのセキュリティグループがLambdaからのインバウンド通信を許可しているかを確認する"
        ],
        "explanation": "【解説】\nLambdaがVPCリソース（RDS）にアクセスするには、Lambda自体をVPCに配置（ENI作成）し、SGで通信許可する必要があります。IAM権限だけではネットワークは繋がりません。",
        "tags": ["第1章", "AWS", "シナリオ", "K3"]
    }
]

# 4. 第2章 金融 (ch2_finance_vol115.json)
q2_fin = [
    {
        "id": "Q2-FIN-V115-01",
        "chapter": "第2章",
        "level": "K4",
        "category": "金融",
        "style": "シナリオ",
        "type": "単一選択",
        "question": "【分析】消費税計算の丸めタイミング。\n複数の商品を注文した際の合計金額に対する消費税計算において、1円の誤差が発生している。\n原因として最も疑わしく、かつ仕様として明確化すべき「丸め処理」のタイミングはどれか。",
        "options": [
            "「明細行ごとに消費税を計算して丸めてから合計する」のか、「税抜金額を合計してから最後に消費税を計算して丸める」のかという、計算順序の仕様不一致",
            "データベースの金額カラムが「浮動小数点型（Float）」ではなく「整数型（Integer）」で定義されているため、小数点以下が保存できていない（金額は通常、整数かDecimalで扱うため、これは原因ではないことが多い）",
            "消費税率が8%（軽減税率）と10%（標準税率）で混在しているが、システムがすべての商品を10%で計算している（これは誤差ではなく大幅な計算ミスになる）",
            "サーバーのタイムゾーンがズレており、日付変更線の関係で消費税率の適用開始日が一日ずれている（1円の誤差の説明としては不自然）"
        ],
        "answer": [
            "「明細行ごとに消費税を計算して丸めてから合計する」のか、「税抜金額を合計してから最後に消費税を計算して丸める」のかという、計算順序の仕様不一致"
        ],
        "explanation": "【解説】\nインボイス制度などでも重要となる「端数処理のタイミング（行単位 vs 伝票単位）」は、1円の誤差を生む典型的な原因です。ここをテストで特定します。",
        "tags": ["第2章", "金融", "シナリオ", "K4"]
    }
]

# 5. 第1章 一般 (ch1_general_vol115.json)
q1_gen = [
    {
        "id": "Q1-GEN-V115-01",
        "chapter": "第1章",
        "level": "K3",
        "category": "一般",
        "style": "シナリオ",
        "type": "単一選択",
        "question": "【適用】技術的負債（Technical Debt）とテストの関係。\n開発チームが「機能追加を優先したいので、コードのリファクタリングと単体テストの修正は後回しにしたい」と言ってきた。\nテストマネージャとして、この判断が将来のテスト活動に与える影響を説明する適切な内容はどれか。",
        "options": [
            "リファクタリングを後回しにすると、コードの複雑度が増してバグが埋め込まれやすくなり、将来の修正コストとテスト工数が指数関数的に増大する（技術的負債の利子）",
            "機能追加を優先することでビジネス価値が早期に提供されるため、テストチームとしても歓迎すべき状況であり、品質よりもスピードを重視してテストを簡略化する",
            "単体テストがなくてもシステムテストでバグを見つければ問題ないため、開発者の負担を減らす意味でも単体テストの廃止を提案する（検出コストの高い工程へのシフト）",
            "技術的負債は開発チーム内部の問題であり、ブラックボックステストを行うテストチームには一切影響がないため、開発チームの判断を尊重する（保守性低下の影響を無視）"
        ],
        "answer": [
            "リファクタリングを後回しにすると、コードの複雑度が増してバグが埋め込まれやすくなり、将来の修正コストとテスト工数が指数関数的に増大する（技術的負債の利子）"
        ],
        "explanation": "【解説】\n技術的負債は「利子」を生みます。コードが汚くなると、解析や修正、影響範囲調査に時間がかかり、結果としてテスト工数も増大し、デグレードリスクが高まります。",
        "tags": ["第1章", "一般", "シナリオ", "K3"]
    }
]

# ==========================================
# ファイル生成 & Index更新処理
# ==========================================
files_content = {
    "ch3_general_vol115.json": q3_gen,
    "ch2_general_vol115.json": q2_gen,
    "ch1_aws_vol115.json": q1_aws,
    "ch2_finance_vol115.json": q2_fin,
    "ch1_general_vol115.json": q1_gen
}

def generate_and_update():
    # 1. ファイル生成
    new_entries = []
    
    print("--- ファイル生成開始 ---")
    for filename, content in files_content.items():
        file_path = os.path.join(OUTPUT_DIR, filename)
        try:
            with open(file_path, 'w', encoding='utf-8') as f:
                json.dump(content, f, ensure_ascii=False, indent=2)
            print(f"作成: {filename}")
            
            # メタデータ抽出（Index用）
            first_q = content[0]
            entry = {
                "path": f"questions/{filename}", # アプリの仕様に合わせたパス
                "chapter": first_q.get("chapter", "不明"),
                "category": first_q.get("category", "不明"),
                "klevel": first_q.get("level", "K2"),
                "qCount": len(content)
            }
            new_entries.append(entry)
            
        except Exception as e:
            print(f"エラー作成中 {filename}: {e}")

    # 2. Index更新
    print("\n--- Index更新開始 ---")
    if not os.path.exists(INDEX_FILE):
        print(f"エラー: {INDEX_FILE} が見つかりません。")
        return

    try:
        with open(INDEX_FILE, 'r', encoding='utf-8') as f:
            index_data = json.load(f)
        
        existing_paths = {item.get("path") for item in index_data.get("chunks", [])}
        added_count = 0
        
        for entry in new_entries:
            if entry["path"] not in existing_paths:
                index_data["chunks"].append(entry)
                print(f"Index追加: {entry['path']}")
                added_count += 1
            else:
                print(f"Indexスキップ（登録済）: {entry['path']}")
        
        if added_count > 0:
            with open(INDEX_FILE, 'w', encoding='utf-8') as f:
                json.dump(index_data, f, ensure_ascii=False, indent=2)
            print(f"Index保存完了: {added_count}件追加")
        else:
            print("Index更新なし")

    except Exception as e:
        print(f"Index更新エラー: {e}")

if __name__ == "__main__":
    generate_and_update()