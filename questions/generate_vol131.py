import json
import os

# 保存先ディレクトリ
OUTPUT_DIR = "."
INDEX_FILE = "index.json"

# ==========================================
# Vol.131 新規問題データ定義
# ==========================================

# 1. 第3章 一般 (ch3_general_vol131.json)
q3_gen = [
    {
        "id": "Q3-GEN-V131-01",
        "chapter": "第3章",
        "level": "K3",
        "category": "一般",
        "style": "シナリオ",
        "type": "単一選択",
        "question": "【適用】テスト戦略（Strategy）とテスト計画（Plan）の使い分け。\n組織全体でアジャイル開発への移行を進めているが、各プロジェクトでテストの方針がバラバラで混乱が生じている。\n組織レベルでの標準化と、プロジェクト固有の柔軟性を両立させるためのドキュメント構成として、最も適切なものはどれか。",
        "options": [
            "組織全体で共通の「テスト戦略」を策定してテストレベルやツール、品質基準の標準を定義し、各プロジェクトではそれを参照しつつ固有のスケジュールやリソースを「テスト計画」に記述する",
            "すべてのプロジェクトのスケジュールとリソースを網羅した巨大な「マスターテスト計画書」を一つだけ作成し、全プロジェクトがその計画書に従って行動する",
            "アジャイル開発ではドキュメントは不要であるため、戦略も計画も作成せず、各チームがその場の判断でテストを実施する",
            "プロジェクトごとに独自の「テスト戦略」をゼロから作成し、組織標準は設けずに各チームの自律性を最大限に尊重する"
        ],
        "answer": [
            "組織全体で共通の「テスト戦略」を策定してテストレベルやツール、品質基準の標準を定義し、各プロジェクトではそれを参照しつつ固有のスケジュールやリソースを「テスト計画」に記述する"
        ],
        "explanation": "【解説】\n「戦略（Strategy）」は組織や複数プロジェクトにまたがる長期的な方針であり、「計画（Plan）」は特定プロジェクトのスコープ、日程、リソースを定義するものです。この2階層で管理するのが一般的です。",
        "tags": ["第3章", "一般", "シナリオ", "K3"]
    }
]

# 2. 第1章 一般 (ch1_general_vol131.json)
q1_gen = [
    {
        "id": "Q1-GEN-V131-01",
        "chapter": "第1章",
        "level": "K3",
        "category": "一般",
        "style": "シナリオ",
        "type": "単一選択",
        "question": "【適用】探索的テストとチャーター（Charter）。\n探索的テストを実施する際、テスターが漫然と操作してしまうのを防ぎ、特定の品質リスクに焦点を当てて効率的に欠陥を見つけたい。\nテストセッションの方向性をガイドするために、事前に準備すべき「チャーター」の記述例として適切なものはどれか。",
        "options": [
            "「ログイン画面を開き、IDを入力し、パスワードを入力し、ログインボタンを押す」という具体的な操作手順",
            "「セキュリティの観点から、入力フォームに対するインジェクション攻撃や境界値の脆弱性を探索し、データの堅牢性を評価する」というミッション形式の記述",
            "「バグをできるだけ多く見つけること」という、テスターのモチベーションを高めるためのスローガン",
            "「画面Aから画面Zまで、すべてのボタンを左から順に1回ずつクリックする」という網羅的な操作指示"
        ],
        "answer": [
            "「セキュリティの観点から、入力フォームに対するインジェクション攻撃や境界値の脆弱性を探索し、データの堅牢性を評価する」というミッション形式の記述"
        ],
        "explanation": "【解説】\nチャーターは詳細な手順書ではなく、「目的（Mission）」や「探索範囲」を示した指針です。これによりテスターの創造性を活かしつつ、焦点の定まったテストが可能になります。",
        "tags": ["第1章", "一般", "シナリオ", "K3"]
    }
]

# 3. 第2章 一般 (ch2_general_vol131.json)
q2_gen = [
    {
        "id": "Q2-GEN-V131-01",
        "chapter": "第2章",
        "level": "K4",
        "category": "一般",
        "style": "シナリオ",
        "type": "単一選択",
        "question": "【分析】デシジョンテーブルテストの矛盾検出。\n仕様書に基づきデシジョンテーブルを作成したところ、「条件A=真 かつ 条件B=真」の組み合わせに対して、仕様書には「処理Xを実行する」という記述と「処理Yを実行する」という記述の両方が存在し、矛盾していることが判明した。\nテスト設計段階での対応として、最も適切なアクションはどれか。",
        "options": [
            "デシジョンテーブル上では、とりあえず「処理X」を採用してテストケースを作成し、テスト実行時にエラーが出たら開発者に報告する",
            "この矛盾は「仕様の不備」であるため、テスト設計を中断し、開発者やステークホルダーに問い合わせて正しい動作を確定させてからテーブルを修正する",
            "両方の処理が実行される可能性があるため、期待結果を「処理X または 処理Y」として定義し、どちらが起きても合格とする",
            "矛盾する組み合わせは「起こり得ない（Impossible）」とみなして、デシジョンテーブルからその列を削除する"
        ],
        "answer": [
            "この矛盾は「仕様の不備」であるため、テスト設計を中断し、開発者やステークホルダーに問い合わせて正しい動作を確定させてからテーブルを修正する"
        ],
        "explanation": "【解説】\nデシジョンテーブル作成の最大のメリットの一つは、このような「仕様の矛盾や抜け漏れ」を設計段階（コーディング前）に発見できることです。曖昧なまま進めず、仕様を確定させることが重要です。",
        "tags": ["第2章", "一般", "シナリオ", "K4"]
    }
]

# 4. 第1章 AWS (ch1_aws_vol131.json)
q1_aws = [
    {
        "id": "Q1-AWS-V131-01",
        "chapter": "第1章",
        "level": "K3",
        "category": "AWS",
        "style": "シナリオ",
        "type": "単一選択",
        "question": "【適用】S3ライフサイクルポリシーのテスト。\n「作成から30日経過したログファイルを、S3標準クラスからGlacier Deep Archiveへ移行する」というライフサイクルルールを設定した。\nこのルールが正しく動作することを検証するための、最も現実的なテスト方法はどれか。",
        "options": [
            "実際にファイルを作成してから30日間待機し、ストレージクラスが変更されるのを毎日目視で確認する",
            "テスト用に一時的にルールを変更し、「作成から1日（または0日）経過」で移行するように設定して、翌日にストレージクラスが変更されていることを確認する",
            "S3のAPIを使ってファイルの「作成日時（LastModified）」を30日前の日付に改ざんし、即座に移行処理が走るかを確認する",
            "AWSサポートに連絡し、特定バケットの時間を30日進めてもらうように依頼する"
        ],
        "answer": [
            "テスト用に一時的にルールを変更し、「作成から1日（または0日）経過」で移行するように設定して、翌日にストレージクラスが変更されていることを確認する"
        ],
        "explanation": "【解説】\nS3のライフサイクル移行は日数ベース（UTC 0時切り替え）で動作するため、数分で結果が出るものではありません。テスト時は日数を「0」や「1」に短縮して検証するのが一般的です。",
        "tags": ["第1章", "AWS", "シナリオ", "K3"]
    }
]

# 5. 第2章 金融 (ch2_finance_vol131.json)
q2_fin = [
    {
        "id": "Q2-FIN-V131-01",
        "chapter": "第2章",
        "level": "K4",
        "category": "金融",
        "style": "シナリオ",
        "type": "単一選択",
        "question": "【分析】うるう年（Leap Year）の利息計算。\n「1年を365日」として日割計算を行う金融商品において、うるう年（366日）の期間を含む利息計算を行う際に発生しやすい不具合はどれか。\nテスト設計で重点的に確認すべきポイントを選択せよ。",
        "options": [
            "うるう年の2月29日が存在することによって、計算式の日数カウントが1日多くなり、分母が固定（365）のままだと利息額が想定よりも多く（366/365倍）計算されてしまうこと",
            "うるう年はシステムのカレンダーが自動的に13ヶ月になるため、1ヶ月分の利息が二重に計上されてしまうこと",
            "うるう年の2月29日は銀行休業日扱いとなるため、その日の利息が一切計算されず、1日分の利息が不足してしまうこと",
            "うるう年は4で割り切れるため、利息計算の端数がすべて切り捨てられてしまい、誤差が大きくなること"
        ],
        "answer": [
            "うるう年の2月29日が存在することによって、計算式の日数カウントが1日多くなり、分母が固定（365）のままだと利息額が想定よりも多く（366/365倍）計算されてしまうこと"
        ],
        "explanation": "【解説】\n「Act/365（実日数/365）」方式の場合、うるう年は分子の実日数が366日になるため、年利よりも多く利息を払うことになります。これが仕様通りか、あるいは366日を分母にする調整が必要かの確認が必須です。",
        "tags": ["第2章", "金融", "シナリオ", "K4"]
    }
]

# ==========================================
# ファイル生成 & Index更新処理
# ==========================================
files_content = {
    "ch3_general_vol131.json": q3_gen,
    "ch1_general_vol131.json": q1_gen,
    "ch2_general_vol131.json": q2_gen,
    "ch1_aws_vol131.json": q1_aws,
    "ch2_finance_vol131.json": q2_fin
}

def generate_and_update():
    # 1. ファイル生成
    new_entries = []
    
    print("--- ファイル生成開始 ---")
    for filename, content in files_content.items():
        file_path = os.path.join(OUTPUT_DIR, filename)
        try:
            with open(file_path, 'w', encoding='utf-8') as f:
                json.dump(content, f, ensure_ascii=False, indent=2)
            print(f"作成: {filename}")
            
            # メタデータ抽出（Index用）
            first_q = content[0]
            entry = {
                "path": f"questions/{filename}", # アプリの仕様に合わせたパス
                "chapter": first_q.get("chapter", "不明"),
                "category": first_q.get("category", "不明"),
                "klevel": first_q.get("level", "K2"),
                "qCount": len(content)
            }
            new_entries.append(entry)
            
        except Exception as e:
            print(f"エラー作成中 {filename}: {e}")

    # 2. Index更新
    print("\n--- Index更新開始 ---")
    if not os.path.exists(INDEX_FILE):
        print(f"エラー: {INDEX_FILE} が見つかりません。")
        return

    try:
        with open(INDEX_FILE, 'r', encoding='utf-8') as f:
            index_data = json.load(f)
        
        existing_paths = {item.get("path") for item in index_data.get("chunks", [])}
        added_count = 0
        
        for entry in new_entries:
            if entry["path"] not in existing_paths:
                index_data["chunks"].append(entry)
                print(f"Index追加: {entry['path']}")
                added_count += 1
            else:
                print(f"Indexスキップ（登録済）: {entry['path']}")
        
        if added_count > 0:
            with open(INDEX_FILE, 'w', encoding='utf-8') as f:
                json.dump(index_data, f, ensure_ascii=False, indent=2)
            print(f"Index保存完了: {added_count}件追加")
        else:
            print("Index更新なし")

    except Exception as e:
        print(f"Index更新エラー: {e}")

if __name__ == "__main__":
    generate_and_update()