import json
import os
import glob

# ファイルが保存されているディレクトリ（環境に合わせて変更してください）
BASE_DIR = "."  # カレントディレクトリの場合

# ==========================================
# 修正データ定義（強化版）
# ==========================================
fixes = {
    # ---------------------------
    # 第1章 一般 (General)
    # ---------------------------
    "Q1-GEN-01": { # 終了基準
        "options": [
            "テスト担当者が自信を持ってリリース可能と判断したタイミング（担当者の主観的評価）",
            "ステークホルダーと事前に合意された、客観的な完了条件（カバレッジや残存リスク等）の達成",
            "プロジェクトの納期（リリース日）が到来し、テスト期間が終了した時点",
            "開発チームリーダーがすべての修正完了を宣言し、品質保証部門がそれを承認した時"
        ],
        "answer": ["ステークホルダーと事前に合意された、客観的な完了条件（カバレッジや残存リスク等）の達成"]
    },
    "Q1-GEN-05": { # テストコントロール
        "options": [
            "テスト進捗状況を定期的に計測し、計画との予実差異を分析してレポートを作成する（モニタリング活動）",
            "計画と現状の乖離を埋めるために、スコープの調整（デスコープ）やリソースの再割り当てを行う",
            "テストケースの設計・実装を行い、テストデータを準備して実行環境を構築する",
            "要件定義書の不明点を洗い出し、開発者や顧客に対して仕様の明確化を求める"
        ],
        "answer": ["計画と現状の乖離を埋めるために、スコープの調整（デスコープ）やリソースの再割り当てを行う"]
    },
    "Q1-GEN-06": { # MTP vs LTP
        "options": [
            "MTPは個別のテストレベルごとの詳細手順を定義し、LTPがプロジェクト全体の指針を示す",
            "MTP（マスターテスト計画）はプロジェクト全体の統括的な方針を示し、LTP（レベルテスト計画）は各レベルの詳細を定義する",
            "MTPとLTPは同一の文書であり、読者対象（管理者向けか実務者向けか）によって呼び方が異なるだけである",
            "LTPが最上位の文書として全体の品質戦略を定義し、MTPはその一部としてスケジュールのみを管理する"
        ],
        "answer": ["MTP（マスターテスト計画）はプロジェクト全体の統括的な方針を示し、LTP（レベルテスト計画）は各レベルの詳細を定義する"]
    },
    "Q1-GEN-09": { # 進捗モニタリング
        "options": [
            "テストケースの準備数・実行数・合格数などの定量的指標と、残存リスクの状況",
            "テスト自動化スクリプトの総行数（LOC）と、メンテナンスにかかった工数",
            "開発チームの週間平均残業時間と、テスト担当者のモチベーションスコア",
            "発見された全欠陥の修正にかかった平均コスト（修正工数）と手戻り率"
        ],
        "answer": ["テストケースの準備数・実行数・合格数などの定量的指標と、残存リスクの状況"]
    },

    # ---------------------------
    # 第3章 医療 (Medical / Evidence)
    # ---------------------------
    "Q3-MED-V53-01": { # ログ不備対応
        "options": [
            "記憶が鮮明なうちに、テスト実施当時の日付と署名を追記し、不備を訂正する（バックデート）",
            "ログ不備は「実施していない」のと同じ（証拠能力なし）と判断し、直ちに該当テストを「再実行」して、正しい日付と署名入りの正規ログを新たに作成する。監査では「記録不備により再実施した」事実を正直に説明する",
            "テスト自体は合格（Pass）しているため、ログの形式的な不備については特記事項として報告書に記載し、そのまま提出する",
            "テストマネージャの権限において、合格の事実を確認した上で代理署名を行い、承認印を押して正式な記録とする"
        ],
        "answer": ["ログ不備は「実施していない」のと同じ（証拠能力なし）と判断し、直ちに該当テストを「再実行」して、正しい日付と署名入りの正規ログを新たに作成する。監査では「記録不備により再実施した」事実を正直に説明する"]
    },
    "Q1-MED-01": { # 医療機器計画
        "options": [
            "最新のデザイントレンドを取り入れた、直感的で美しいユーザーインターフェース（UI）の設計",
            "安全性クラスに応じた検証活動の定義と、要件からテストまでのトレーサビリティの確保",
            "開発効率を最大化し、市場投入までの期間（Time to Market）を短縮するためのアジャイルプラクティス",
            "競合他社の製品機能を分析し、差別化要因となる独自のアルゴリズムを実装すること"
        ],
        "answer": ["安全性クラスに応じた検証活動の定義と、要件からテストまでのトレーサビリティの確保"]
    },
    "Q1-MED-05": { # SOUP
        "options": [
            "医療機器規制の対象外となる、事務処理や在庫管理のための汎用ソフトウェア",
            "出所不明または開発プロセスが不明なサードパーティ製ソフトウェア（OS、ライブラリ等）",
            "自社で独自に開発し、ソースコードや開発履歴が完全に管理されているコアモジュール",
            "テスト実行を自動化するために導入された、検証済みの商用テストツール"
        ],
        "answer": ["出所不明または開発プロセスが不明なサードパーティ製ソフトウェア（OS、ライブラリ等）"]
    },

    # ---------------------------
    # 第1章 AWS / クラウド
    # ---------------------------
    "Q1-AWS-01": { # オートスケーリングリスク
        "options": [
            "リージョン間のネットワーク遅延による、画面描画のわずかなタイムラグ",
            "スケーリング実行時のデータ整合性維持と、リソース増減に伴うステートレス性の確保（弾力性のリスク）",
            "EC2インスタンスのOSライセンス違反や、意図しないミドルウェアのバージョンアップ",
            "未使用リソースの削除忘れによる、月額利用料金の微小な増加"
        ],
        "answer": ["スケーリング実行時のデータ整合性維持と、リソース増減に伴うステートレス性の確保（弾力性のリスク）"]
    },
    "Q1-CLD-01": { # シフトレフト
        "options": [
            "テスト工程をウォーターフォールモデルの右側（リリース直前）に集中させ、品質を最終確認すること",
            "開発プロセスの初期段階（要件定義や設計）からテスト活動を開始し、欠陥の作り込みを防ぐこと",
            "開発チームとは物理的に離れた場所にテストチームを配置し（Left-side）、独立性を高めること",
            "手動テストを廃止し、すべてのテストレベルにおいて自動テストのみを実施すること"
        ],
        "answer": ["開発プロセスの初期段階（要件定義や設計）からテスト活動を開始し、欠陥の作り込みを防ぐこと"]
    },
    "Q1-CLD-03": { # カナリアリリース
        "options": [
            "すべてのユーザーに対して新機能を一斉に公開し、市場からのフィードバックを最速で収集する戦略",
            "新バージョンを一部のユーザーのみに公開して本番環境での動作を検証し、問題があれば即座に切り戻すことで影響を最小化する戦略",
            "開発環境（Staging）と本番環境（Production）の構成差異を完全になくし、デプロイ時の予期せぬエラーをゼロにする戦略",
            "高負荷に耐えられるかを確認するため、本番環境に対して意図的に攻撃的なトラフィックを送信するストレステスト戦略"
        ],
        "answer": ["新バージョンを一部のユーザーのみに公開して本番環境での動作を検証し、問題があれば即座に切り戻すことで影響を最小化する戦略"]
    },
    "Q2-CLD-01": { # クラウド品質指標
        "options": [
            "SLA（サービスレベル合意）およびSLO（サービスレベル目標）",
            "ファンクションポイント（FP）に基づく開発規模と生産性",
            "循環的複雑度（Cyclomatic Complexity）とコードカバレッジ",
            "開発チームの平均年齢と経験年数"
        ],
        "answer": ["SLA（サービスレベル合意）およびSLO（サービスレベル目標）"]
    }
}

def refine_questions():
    # jsonファイルを探す
    all_files = glob.glob(os.path.join(BASE_DIR, "*.json"))
    updated_count = 0

    print("問題データの修正を開始します...")

    for file_path in all_files:
        filename = os.path.basename(file_path)
        # index.jsonなどはスキップ
        if filename == "index.json" or filename.startswith("refine"):
            continue
            
        try:
            with open(file_path, 'r', encoding='utf-8') as f:
                data = json.load(f)
            
            if not isinstance(data, list):
                continue

            file_modified = False
            
            for q in data:
                q_id = q.get("id")
                
                # fixesリストにIDがあれば修正を適用
                if q_id in fixes:
                    fix_data = fixes[q_id]
                    
                    # 選択肢の更新
                    if "options" in fix_data:
                        q["options"] = fix_data["options"]
                    
                    # 正解の更新
                    if "answer" in fix_data:
                        q["answer"] = fix_data["answer"]
                        
                    print(f"  修正適用: {q_id} ({filename})")
                    file_modified = True

            if file_modified:
                with open(file_path, 'w', encoding='utf-8') as f:
                    json.dump(data, f, ensure_ascii=False, indent=2)
                updated_count += 1
                
        except Exception as e:
            print(f"  読み込みエラー: {filename} - {e}")

    print("-" * 30)
    print(f"完了: 合計 {updated_count} ファイルの問題を修正しました。")

if __name__ == "__main__":
    refine_questions()