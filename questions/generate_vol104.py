import json
import os

# 保存先ディレクトリ
OUTPUT_DIR = "."
INDEX_FILE = "index.json"

# ==========================================
# Vol.104 新規問題データ定義
# ==========================================

# 1. 第1章 一般 (ch1_general_vol104.json)
q1_gen = [
    {
        "id": "Q1-GEN-V104-01",
        "chapter": "第1章",
        "level": "K4",
        "category": "一般",
        "style": "シナリオ",
        "type": "単一選択",
        "question": "【分析】テスト戦略の策定。\n「短期間で市場に投入する必要がある新規Webサービス（MVP）」のテスト戦略を立案する。\n仕様は頻繁に変更される見込みである。\nこのプロジェクトの特性に最も適したテストアプローチはどれか。",
        "options": [
            "仕様変更に追従するために、詳細なIEEE 829準拠のテスト手順書を毎回完璧にメンテナンスし、ドキュメントの整合性を最優先する（ドキュメント保守コストが破綻する）",
            "変更に強い「探索的テスト」を主軸に据え、回帰テストは重要なハッピーパスのみを自動化して、ドキュメント作成よりも実行とフィードバックのサイクルを重視する",
            "品質を担保するために、すべての機能を網羅する手動テストケースを作成し、変更があるたびに全量を再実行することを義務付ける（スピード感を損なう）",
            "仕様が固まるまでテスト活動は一切行わず、開発完了直前の「安定化期間」にまとめてテストを行うことで手戻りを防ぐ（ビッグバンテストのリスク）"
        ],
        "answer": [
            "変更に強い「探索的テスト」を主軸に据え、回帰テストは重要なハッピーパスのみを自動化して、ドキュメント作成よりも実行とフィードバックのサイクルを重視する"
        ],
        "explanation": "【解説】\nMVP（Minimum Viable Product）やアジャイル開発では、重厚なドキュメントよりも「変化への対応」が重視されます。探索的テストと軽量な自動化の組み合わせが定石です。",
        "tags": ["第1章", "一般", "シナリオ", "K4"]
    }
]

# 2. 第2章 一般 (ch2_general_vol104.json)
q2_gen = [
    {
        "id": "Q2-GEN-V104-01",
        "chapter": "第2章",
        "level": "K3",
        "category": "一般",
        "style": "シナリオ",
        "type": "単一選択",
        "question": "【適用】テストモニタリング（進捗管理）。\nテスト実行フェーズの中盤で、テストケースの消化率（実行数）は計画通りだが、欠陥発見数が予想よりも大幅に多い。\n開発チームの修正作業が追いつかず、再テスト待ちのアイテムが積み上がっている。\nこの状況に対するコントロール策として最も適切なものはどれか。",
        "options": [
            "テスト実行を一時的にスローダウンまたは中断し、開発チームが修正に集中できる期間（品質安定化期間）を設けるようプロジェクトマネージャに提案する",
            "テストチームの人数をさらに増やしてテスト実行のペースを上げ、未発見のバグを全て出し切ることで、開発チームにプレッシャーをかける（開発がパンクして逆効果）",
            "発見されたバグの多くは些細なものだと仮定し、重要度「低」以下のバグ報告を禁止することで、開発チームの負担を見かけ上減らす（品質リスクの隠蔽）",
            "開発チームのスキル不足が原因であるため、テストチームが代わりにコード修正を行うよう役割分担を変更する（テストの独立性と責任分界点の崩壊）"
        ],
        "answer": [
            "テスト実行を一時的にスローダウンまたは中断し、開発チームが修正に集中できる期間（品質安定化期間）を設けるようプロジェクトマネージャに提案する"
        ],
        "explanation": "【解説】\nバグが多すぎて修正が追いつかない場合、これ以上バグを見つけても「修正されない在庫」が増えるだけです。全体最適の視点で、工程の調整（スローダウンや修正期間の確保）を提案するのがマネージャの役割です。",
        "tags": ["第2章", "一般", "シナリオ", "K3"]
    }
]

# 3. 第3章 一般 (ch3_general_vol104.json)
q3_gen = [
    {
        "id": "Q3-GEN-V104-01",
        "chapter": "第3章",
        "level": "K3",
        "category": "一般",
        "style": "シナリオ",
        "type": "単一選択",
        "question": "【適用】テストチームのナレッジマネジメント。\n特定のドメイン知識（業務知識）を持つベテランテスターAさんに依存しており、Aさんが休むとテスト設計が進まない。\nこの「属人化リスク」を解消するための具体的なアクションはどれか。",
        "options": [
            "Aさんの給与を上げて離職を防ぐとともに、Aさん専任のアシスタントをつけて、Aさんの負担を減らす（依存構造は変わらない）",
            "Aさんに「ペアテスト」や「モブテスト」のファシリテーターを依頼し、実際のテスト活動を通じて他のメンバーに思考プロセスや観点を共有・伝承させる",
            "Aさんに対して、業務知識を全てドキュメント化するまでテスト実務を禁止する業務命令を出し、マニュアル作成に専念させる（プロジェクト進捗への悪影響）",
            "Aさんの知識は属人的な才能であり移転不可能であるため、Aさんが引退するまでにAIに学習させて代替させる計画を立てる（技術的実現性が不透明）"
        ],
        "answer": [
            "Aさんに「ペアテスト」や「モブテスト」のファシリテーターを依頼し、実際のテスト活動を通じて他のメンバーに思考プロセスや観点を共有・伝承させる"
        ],
        "explanation": "【解説】\n形式知化（ドキュメント化）も重要ですが、暗黙知の移転には「共同作業（ペアリング）」が最も即効性があり効果的です。",
        "tags": ["第3章", "一般", "シナリオ", "K3"]
    }
]

# 4. 第1章 AWS (ch1_aws_vol104.json)
q1_aws = [
    {
        "id": "Q1-AWS-V104-01",
        "chapter": "第1章",
        "level": "K3",
        "category": "AWS",
        "style": "シナリオ",
        "type": "単一選択",
        "question": "【適用】データの暗号化テスト。\nS3バケットに保存される機密データについて、「サーバーサイド暗号化（SSE-KMS）」が強制されていることを確認したい。\nコンプライアンス要件を満たすための適切な検証方法はどれか。",
        "options": [
            "S3バケットポリシーで「暗号化ヘッダーを含まないPUTリクエストを拒否（Deny）」する設定を行い、実際に暗号化なしでアップロードしてエラーになることを確認する",
            "アップロードされたファイルをダウンロードし、テキストエディタで開いて文字化けしていることを目視で確認する（透過的に復号されるため確認にならない）",
            "AWSのサポートセンターに問い合わせて、自分のアカウントが暗号化されているか保証してもらう（責任共有モデルの誤解）",
            "全てのファイルをクライアントサイドで手動暗号化してからアップロードする運用ルールを定め、徹底されているか担当者にヒアリングする（システム的な強制力がない）"
        ],
        "answer": [
            "S3バケットポリシーで「暗号化ヘッダーを含まないPUTリクエストを拒否（Deny）」する設定を行い、実際に暗号化なしでアップロードしてエラーになることを確認する"
        ],
        "explanation": "【解説】\nセキュリティテストでは「ポリシーによる強制（Deny）」と「ネガティブテスト（拒否されることの確認）」がセットで必要です。S3のSSEは自動復号されるため、ダウンロードしたファイルを見ても暗号化の有無は判断できません。",
        "tags": ["第1章", "AWS", "シナリオ", "K3"]
    }
]

# 5. 第2章 金融 (ch2_finance_vol104.json)
q2_fin = [
    {
        "id": "Q2-FIN-V104-01",
        "chapter": "第2章",
        "level": "K3",
        "category": "金融",
        "style": "シナリオ",
        "type": "単一選択",
        "question": "【適用】職務分掌（Segregation of Duties）のテスト。\n金融システムの内部統制において、「振込データの作成者」と「承認者」は別人でなければならない。\nこの権限ロジックを検証するためのテストケースとして、不可欠なものはどれか。",
        "options": [
            "作成権限を持つユーザーAがデータを作成し、承認権限を持つユーザーBが承認できることを確認する（正常系のみでは不十分）",
            "作成権限と承認権限の両方を持つ（スーパーユーザー）ユーザーCが、自分で作成したデータを自分で承認しようとした際に、システムがエラーまたは警告を出してブロックすることを確認する",
            "権限のないユーザーDがメニュー画面を開こうとしたときに、画面が表示されないことを確認する（アクセス制御の一部だが、職務分掌の核心ではない）",
            "データベースの権限テーブルを直接書き換えて、全員が承認権限を持てるように設定変更できるか試す（運用セキュリティの話であり、アプリロジックのテストではない）"
        ],
        "answer": [
            "作成権限と承認権限の両方を持つ（スーパーユーザー）ユーザーCが、自分で作成したデータを自分で承認しようとした際に、システムがエラーまたは警告を出してブロックすることを確認する"
        ],
        "explanation": "【解説】\n職務分掌（SoD）の核心は「自己承認の禁止」です。権限を持っていても、自分が作ったものは承認できないというロジックの検証が必須です。",
        "tags": ["第2章", "金融", "シナリオ", "K3"]
    }
]

# ==========================================
# ファイル生成 & Index更新処理
# ==========================================
files_content = {
    "ch1_general_vol104.json": q1_gen,
    "ch2_general_vol104.json": q2_gen,
    "ch3_general_vol104.json": q3_gen,
    "ch1_aws_vol104.json": q1_aws,
    "ch2_finance_vol104.json": q2_fin
}

def generate_and_update():
    # 1. ファイル生成
    new_entries = []
    
    print("--- ファイル生成開始 ---")
    for filename, content in files_content.items():
        file_path = os.path.join(OUTPUT_DIR, filename)
        try:
            with open(file_path, 'w', encoding='utf-8') as f:
                json.dump(content, f, ensure_ascii=False, indent=2)
            print(f"作成: {filename}")
            
            # メタデータ抽出（Index用）
            first_q = content[0]
            entry = {
                "path": f"questions/{filename}", # アプリの仕様に合わせたパス
                "chapter": first_q.get("chapter", "不明"),
                "category": first_q.get("category", "不明"),
                "klevel": first_q.get("level", "K2"),
                "qCount": len(content)
            }
            new_entries.append(entry)
            
        except Exception as e:
            print(f"エラー作成中 {filename}: {e}")

    # 2. Index更新
    print("\n--- Index更新開始 ---")
    if not os.path.exists(INDEX_FILE):
        print(f"エラー: {INDEX_FILE} が見つかりません。")
        return

    try:
        with open(INDEX_FILE, 'r', encoding='utf-8') as f:
            index_data = json.load(f)
        
        existing_paths = {item.get("path") for item in index_data.get("chunks", [])}
        added_count = 0
        
        for entry in new_entries:
            if entry["path"] not in existing_paths:
                index_data["chunks"].append(entry)
                print(f"Index追加: {entry['path']}")
                added_count += 1
            else:
                print(f"Indexスキップ（登録済）: {entry['path']}")
        
        if added_count > 0:
            with open(INDEX_FILE, 'w', encoding='utf-8') as f:
                json.dump(index_data, f, ensure_ascii=False, indent=2)
            print(f"Index保存完了: {added_count}件追加")
        else:
            print("Index更新なし")

    except Exception as e:
        print(f"Index更新エラー: {e}")

if __name__ == "__main__":
    generate_and_update()