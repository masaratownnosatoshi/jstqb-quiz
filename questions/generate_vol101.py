import json
import os

# 保存先ディレクトリ
OUTPUT_DIR = "."
INDEX_FILE = "index.json"

# ==========================================
# Vol.101 新規問題データ定義
# ==========================================

# 1. 第3章 AI/ML (ch3_ai_vol101.json)
q3_ai = [
    {
        "id": "Q3-AI-V101-01",
        "chapter": "第3章",
        "level": "K4",
        "category": "AI/ML",
        "style": "シナリオ",
        "type": "単一選択",
        "question": "【分析】AIモデルの公平性（Fairness）テスト。\n人材採用支援AIを導入したが、特定の性別や年齢層に対して不利な判定が出ている疑いがある。\nこの「バイアス」の原因を特定し、改善するためにテスターが最初に行うべき分析アクションはどれか。",
        "options": [
            "AIの判断ロジックはブラックボックスであり解析不可能であるため、テストデータではなくアルゴリズム自体のパラメータをランダムに調整して、出力結果のバランスが良くなる設定値を探索する",
            "トレーニングデータセット（学習データ）の構成比率を分析し、特定の属性グループに対するデータ不足や、過去の採用履歴に含まれる人間由来のバイアスが学習データに反映されていないかを確認する",
            "AIが出した不採用通知に対して、人間が一件ずつ再審査を行い、AIの間違いを全て手動で修正してから結果を通知する運用フローに変更する（根本解決ではない）",
            "バイアスは統計的な誤差に過ぎないため、テストデータのサンプル数を単純に10倍に増やし、大数の法則によって誤差が収束することを期待して再学習させる（データの質の問題を無視）"
        ],
        "answer": [
            "トレーニングデータセット（学習データ）の構成比率を分析し、特定の属性グループに対するデータ不足や、過去の採用履歴に含まれる人間由来のバイアスが学習データに反映されていないかを確認する"
        ],
        "explanation": "【解説】\nAIのバイアスの大半は「データ」に起因します。アルゴリズムをいじる前に、学習データ自体が公平か（Data Bias）を疑うのが鉄則です。",
        "tags": ["第3章", "AI/ML", "シナリオ", "K4"]
    }
]

# 2. 第2章 セキュリティ (ch2_security_vol101.json)
q2_sec = [
    {
        "id": "Q2-SEC-V101-01",
        "chapter": "第2章",
        "level": "K3",
        "category": "セキュリティ",
        "style": "シナリオ",
        "type": "単一選択",
        "question": "【適用】DevSecOpsにおける「シフトレフト」の実践。\nリリース直前の侵入テスト（Penetration Test）で脆弱性が発見され、リリース延期が常態化している。\nセキュリティ品質を早期に確保し、手戻りを減らすためのパイプライン改善策はどれか。",
        "options": [
            "セキュリティ専門チームによる手動診断を、開発者のすべてのコミット（Push）に対してリアルタイムで実施するようにプロセスを厳格化し、承認がないコードはマージできないようにする（開発スピードが著しく低下する）",
            "CI/CDパイプラインにSAST（静的アプリケーションセキュリティテスト）やSCA（ソフトウェア構成分析）ツールを組み込み、コーディング段階やビルド時に脆弱なコードやライブラリを自動検知してフィードバックする",
            "開発者がコードを書く際にセキュリティを意識しすぎると生産性が下がるため、テスト環境での動的スキャン（DAST）の回数を増やし、質より量でカバーするアプローチをとる",
            "脆弱性は攻撃されて初めて実害が出るものであるため、リリース前のテストは最小限にし、本番環境にWAF（Web Application Firewall）を導入して攻撃をブロックすることだけに注力する（根本対策の放棄）"
        ],
        "answer": [
            "CI/CDパイプラインにSAST（静的アプリケーションセキュリティテスト）やSCA（ソフトウェア構成分析）ツールを組み込み、コーディング段階やビルド時に脆弱なコードやライブラリを自動検知してフィードバックする"
        ],
        "explanation": "【解説】\nDevSecOpsの鍵は「自動化」と「早期発見」です。SAST/SCAをパイプラインに統合することで、開発者はコードを書いた直後にフィードバックを得られます。",
        "tags": ["第2章", "セキュリティ", "シナリオ", "K3"]
    }
]

# 3. 第1章 一般 (ch1_general_vol101.json)
q1_gen = [
    {
        "id": "Q1-GEN-V101-01",
        "chapter": "第1章",
        "level": "K3",
        "category": "一般",
        "style": "シナリオ",
        "type": "単一選択",
        "question": "【適用】回帰テストの肥大化対策。\nアジャイル開発が進むにつれて回帰テストケースが増え続け、実行時間がスプリント期間内に収まらなくなってきた。\n品質リスクを管理しつつ、テスト時間を短縮するための戦略として最も適切なものはどれか。",
        "options": [
            "過去に作成した全ての回帰テストケースを夜間バッチで並列実行し、サーバーリソースを無限に増強することで、どれだけ数が増えても全量実行を維持する（コストが指数関数的に増大する）",
            "変更の影響範囲分析（Impact Analysis）に基づき、リスクの高い機能や変更に関連するテストケースを優先的に選択して実行し、リスクの低い安定した機能のテストは間引く（または頻度を下げる）",
            "回帰テストは基本的に「バグが出ないこと」を確認する作業であり付加価値が低いため、単体テストが通っていればシステムレベルの回帰テストは廃止しても問題ないと判断する",
            "テスト自動化エンジニアを大量に採用し、手動テストを一切廃止して100%自動化することを目指すが、メンテナンスコストについては考慮しない（保守地獄のリスク）"
        ],
        "answer": [
            "変更の影響範囲分析（Impact Analysis）に基づき、リスクの高い機能や変更に関連するテストケースを優先的に選択して実行し、リスクの低い安定した機能のテストは間引く（または頻度を下げる）"
        ],
        "explanation": "【解説】\n「全量実行」はいつか破綻します。スマートな戦略は「選択的実行（Test Selection）」と「リスクベース」の組み合わせです。",
        "tags": ["第1章", "一般", "シナリオ", "K3"]
    }
]

# 4. 第2章 一般 (ch2_general_vol101.json)
q2_gen = [
    {
        "id": "Q2-GEN-V101-01",
        "chapter": "第2章",
        "level": "K4",
        "category": "一般",
        "style": "シナリオ",
        "type": "単一選択",
        "question": "【分析】欠陥除去効率（DRE）の改善。\nプロジェクトのDRE分析の結果、「要件定義フェーズでの欠陥除去率」が5%と極端に低いことが判明した。\nその結果、設計以降のフェーズで仕様の手戻りが多発している。\nこのボトルネックを解消するための具体的なプロセス改善策はどれか。",
        "options": [
            "要件定義書は自然言語で書かれており曖昧さが残るのは仕方がないため、要件フェーズでの活動は現状維持とし、詳細設計フェーズでのレビュー時間を倍増させてカバーする（手戻りコスト削減にならない）",
            "要件定義書のインスペクション（公式レビュー）を導入し、「テスト担当者」をレビューアとして参加させることで、テスト可能性（Testability）や曖昧さの視点から欠陥を早期検出する",
            "要件定義ツール（RMツール）を導入すれば、ツールの機能によって矛盾が自動的に解消されるため、人間のレビュープロセスを見直す必要はない（ツールへの過度な期待）",
            "開発者に要件定義書の執筆を任せるのをやめ、顧客自身に詳細な仕様書を書いてもらうことで、要件の認識齟齬をゼロにする（顧客に開発責任を転嫁する非現実的な案）"
        ],
        "answer": [
            "要件定義書のインスペクション（公式レビュー）を導入し、「テスト担当者」をレビューアとして参加させることで、テスト可能性（Testability）や曖昧さの視点から欠陥を早期検出する"
        ],
        "explanation": "【解説】\n要件フェーズのDRE向上には「テスト担当者の参加」が特効薬です。「テストできるか？」という視点は、要件の曖昧さを排除するのに最強のフィルターとなります。",
        "tags": ["第2章", "一般", "シナリオ", "K4"]
    }
]

# 5. 第3章 一般 (ch3_general_vol101.json)
q3_gen = [
    {
        "id": "Q3-GEN-V101-01",
        "chapter": "第3章",
        "level": "K3",
        "category": "一般",
        "style": "シナリオ",
        "type": "単一選択",
        "question": "【適用】タックマンモデルに基づくチームビルディング。\n新設されたテストチームは現在「混乱期（Storming）」にあり、メンバー間で意見の対立やリーダーへの反発が生じている。\nこの段階において、テストマネージャが取るべきリーダーシップスタイルはどれか。",
        "options": [
            "対立はチームの調和を乱す有害なものとみなし、反発するメンバーを排除または厳重注意して、強制的に規律を守らせる（チームの成長機会を奪う）",
            "チームの対立には介入せず、メンバー同士が自然に解決策を見つけるまで、距離を置いて静観する「委任型」のスタイルを貫く（混乱が長引くリスク）",
            "対立は成長痛であると捉え、コーチング型のアプローチでメンバーの意見を傾聴しつつ、共通の目的と役割分担を再確認させ、対立を建設的な議論へと導く",
            "チームビルディングのための飲み会やゲーム大会を頻繁に開催し、業務上の課題解決よりも、仲良くなることを最優先にする（本質的な対立解消にならない）"
        ],
        "answer": [
            "対立は成長痛であると捉え、コーチング型のアプローチでメンバーの意見を傾聴しつつ、共通の目的と役割分担を再確認させ、対立を建設的な議論へと導く"
        ],
        "explanation": "【解説】\n混乱期に必要なのは「対立の排除」ではなく「対立の解消支援」です。コーチングと方向付け（Direction）のバランスが求められます。",
        "tags": ["第3章", "一般", "シナリオ", "K3"]
    }
]

# ==========================================
# ファイル生成 & Index更新処理
# ==========================================
files_content = {
    "ch3_ai_vol101.json": q3_ai,
    "ch2_security_vol101.json": q2_sec,
    "ch1_general_vol101.json": q1_gen,
    "ch2_general_vol101.json": q2_gen,
    "ch3_general_vol101.json": q3_gen
}

def generate_and_update():
    # 1. ファイル生成
    new_entries = []
    
    print("--- ファイル生成開始 ---")
    for filename, content in files_content.items():
        file_path = os.path.join(OUTPUT_DIR, filename)
        try:
            with open(file_path, 'w', encoding='utf-8') as f:
                json.dump(content, f, ensure_ascii=False, indent=2)
            print(f"作成: {filename}")
            
            # メタデータ抽出（Index用）
            first_q = content[0]
            entry = {
                "path": f"questions/{filename}", # アプリの仕様に合わせたパス
                "chapter": first_q.get("chapter", "不明"),
                "category": first_q.get("category", "不明"),
                "klevel": first_q.get("level", "K2"),
                "qCount": len(content)
            }
            new_entries.append(entry)
            
        except Exception as e:
            print(f"エラー作成中 {filename}: {e}")

    # 2. Index更新
    print("\n--- Index更新開始 ---")
    if not os.path.exists(INDEX_FILE):
        print(f"エラー: {INDEX_FILE} が見つかりません。")
        return

    try:
        with open(INDEX_FILE, 'r', encoding='utf-8') as f:
            index_data = json.load(f)
        
        existing_paths = {item.get("path") for item in index_data.get("chunks", [])}
        added_count = 0
        
        for entry in new_entries:
            if entry["path"] not in existing_paths:
                index_data["chunks"].append(entry)
                print(f"Index追加: {entry['path']}")
                added_count += 1
            else:
                print(f"Indexスキップ（登録済）: {entry['path']}")
        
        if added_count > 0:
            with open(INDEX_FILE, 'w', encoding='utf-8') as f:
                json.dump(index_data, f, ensure_ascii=False, indent=2)
            print(f"Index保存完了: {added_count}件追加")
        else:
            print("Index更新なし")

    except Exception as e:
        print(f"Index更新エラー: {e}")

if __name__ == "__main__":
    generate_and_update()