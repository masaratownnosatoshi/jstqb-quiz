import json
import os

OUTPUT_FILE = "ch3_ai_extra_high_4.json"

new_questions = [
  {
    "id": "Q-AI-HIGH-4-01",
    "chapter": "第3章",
    "level": "K4",
    "category": "AI倫理",
    "style": "シナリオ",
    "type": "単一選択",
    "question": "【分析】ローン審査AIにおいて、「人種」や「性別」といった保護属性は学習データから削除していた。\nしかし、リリース後の監査で「特定の郵便番号（居住地域）」を持つ人々の審査通過率が極端に低いことが判明し、結果として人種差別的なバイアスが発生していると指摘された。\n\nこの現象を何と呼び、どのような対策が必要か。",
    "options": [
      "現象：間接的差別（Proxy Discrimination） / 対策：相関の高い代理変数（Proxy Variable）も特定して除外・調整する",
      "現象：直接的差別 / 対策：保護属性を再度学習データに加える",
      "現象：データポイズニング / 対策：セキュリティ監査を行う",
      "現象：過学習 / 対策：ドロップアウト層を追加する"
    ],
    "answer": [
      "現象：間接的差別（Proxy Discrimination） / 対策：相関の高い代理変数（Proxy Variable）も特定して除外・調整する"
    ],
    "explanation": "【解説】\n保護属性（人種など）を削除しても、それと強い相関がある別の変数（居住地域、収入、学校名など）が「代理変数（Proxy）」となり、結果的に差別を引き起こすことを「間接的差別」と呼びます。\n単に項目を消すだけでなく、相関関係を分析してバイアスを緩和する処理が必要です。",
    "tags": ["AI", "倫理", "バイアス", "公平性"]
  },
  {
    "id": "Q-AI-HIGH-4-02",
    "chapter": "第3章",
    "level": "K4",
    "category": "MLOps",
    "style": "適用",
    "type": "単一選択",
    "question": "【適用】新しい検索ランキングモデルを本番環境にデプロイしたい。\nしかし、新モデルがユーザー体験を損なうリスクがあるため、実際のユーザーには「現行モデル（v1）」の結果を表示し続けたい。\nその裏で、同じリクエストを「新モデル（v2）」にも流して推論させ、v1とv2の出力をログとして比較・検証する手法を取りたい。\n\nこのデプロイ戦略はどれか。",
    "options": [
      "カナリアリリース（Canary Release）",
      "シャドーデプロイ（Shadow Deployment）",
      "Blue-Greenデプロイメント",
      "A/Bテスト"
    ],
    "answer": [
      "シャドーデプロイ（Shadow Deployment）"
    ],
    "explanation": "【解説】\nユーザーに影響を与えずに、本番トラフィックを使って新モデルの性能やエラーを検証する手法を「シャドーデプロイ」と呼びます。\n・カナリア/ABテスト：一部ユーザーに実際に新モデルの結果を見せるため、リスクがあります。\n・Blue-Green：一気に切り替える（または戻す）手法です。",
    "tags": ["AI", "MLOps", "デプロイ"]
  },
  {
    "id": "Q-AI-HIGH-4-03",
    "chapter": "第3章",
    "level": "K4",
    "category": "データ品質",
    "style": "分析",
    "type": "単一選択",
    "question": "【分析】画像分類モデルの精度が上がらない原因を調査したところ、学習データセットの中に「猫の画像なのに『犬』とラベル付けされている」ような誤ったデータ（ラベルノイズ）が多数混入していることが分かった。\n\nデータ再収集が難しい場合、モデル側で取れる対策として最も適切なものはどれか。",
    "options": [
      "ラベルスムージング（Label Smoothing）や、ノイズに頑健な損失関数（Loss Function）を使用する",
      "学習率（Learning Rate）を極端に大きく設定する",
      "モデルの層を深くして、複雑なパターンを記憶させる",
      "バッチサイズを1（最小）にして学習する"
    ],
    "answer": [
      "ラベルスムージング（Label Smoothing）や、ノイズに頑健な損失関数（Loss Function）を使用する"
    ],
    "explanation": "【解説】\nラベルノイズがある場合、モデルが「誤った正解」に無理やり合わせようとして過学習し、性能が落ちます。\n「ラベルスムージング（正解ラベルの確率を1.0ではなく0.9などにする）」や、外れ値の影響を受けにくい損失関数を使うことで、ノイズの影響を緩和できます。",
    "tags": ["AI", "データ品質", "ノイズ対策"]
  },
  {
    "id": "Q-AI-HIGH-4-04",
    "chapter": "第3章",
    "level": "K4",
    "category": "防御手法",
    "style": "適用",
    "type": "単一選択",
    "question": "【適用】顔認証システムに対し、ノイズを加えた画像で誤認識させる「敵対的攻撃（Adversarial Attack）」への懸念がある。\nこの攻撃に対する防御策として、あらかじめ敵対的サンプル（攻撃用画像）を生成し、それを正しいラベルと共に学習データに混ぜてモデルを鍛え直す手法を何と呼ぶか。",
    "options": [
      "敵対的学習（Adversarial Training）",
      "転移学習（Transfer Learning）",
      "蒸留（Distillation）",
      "データ拡張（Data Augmentation）"
    ],
    "answer": [
      "敵対的学習（Adversarial Training）"
    ],
    "explanation": "【解説】\n攻撃データを自ら作り出し、それを「これは攻撃だ（あるいは正しいクラスはこれだ）」と教え込むことで、攻撃に対する耐性（ロバストネス）を高める手法を「敵対的学習（Adversarial Training）」と呼びます。\n現時点で最も有効な防御策の一つとされています。",
    "tags": ["AI", "セキュリティ", "防御", "Adversarial"]
  },
  {
    "id": "Q-AI-HIGH-4-05",
    "chapter": "第3章",
    "level": "K3",
    "category": "テスト技法",
    "style": "シナリオ",
    "type": "単一選択",
    "question": "【適用】OCR（文字認識）AIのテストにおいて、メタモルフィックテストを適用したい。\nこの場合の「メタモルフィック関係（MR）」として、最も適切な例はどれか。",
    "options": [
      "元の画像の背景色を反転させても、認識される文字の内容は変わらないはずである",
      "元の画像を180度回転させたら、認識結果も逆さまの文字になるはずである",
      "元の画像を縮小したら、処理時間が短くなるはずである",
      "元の画像にノイズを加えたら、必ず認識に失敗するはずである"
    ],
    "answer": [
      "元の画像の背景色を反転させても、認識される文字の内容は変わらないはずである"
    ],
    "explanation": "【解説】\nメタモルフィック関係とは「入力の変化に対して、出力がどう変化すべきか（あるいは不変であるべきか）」という関係性です。\n文字認識において「背景色を変えても文字は読めるべき（不変性）」は有効なMRです。\n※「必ず失敗する」といった挙動は保証できないため、MRとしては不適切です。",
    "tags": ["AI", "テスト技法", "メタモルフィック"]
  }
]

def create_ch3_high_4():
    print(f"--- 第3章 追加難問Part4 {OUTPUT_FILE} の作成 ---")
    try:
        with open(OUTPUT_FILE, 'w', encoding='utf-8') as f:
            json.dump(new_questions, f, ensure_ascii=False, indent=2)
        print(f"✅ 作成完了: {len(new_questions)} 問を追加しました。")
    except Exception as e:
        print(f"❌ エラー: {e}")

if __name__ == "__main__":
    create_ch3_high_4()
    input("エンターキーを押して終了...")