import json
import os

# 保存先ディレクトリ
OUTPUT_DIR = "."
INDEX_FILE = "index.json"

# ==========================================
# Vol.117 新規問題データ定義
# ==========================================

# 1. 第3章 一般 (ch3_general_vol117.json)
q3_gen = [
    {
        "id": "Q3-GEN-V117-01",
        "chapter": "第3章",
        "level": "K3",
        "category": "一般",
        "style": "シナリオ",
        "type": "単一選択",
        "question": "【適用】テストプロセス改善（TPI Next）のステップアップ。\n現在、組織の成熟度は「レベルA（制御された）」に到達している。\n次の「レベルB（効率的な）」へ進むために、テストマネージャが理解しておくべきTPI Nextモデルの構造的特徴はどれか。",
        "options": [
            "レベルBに到達するためには、すべてのキーエリア（Key Areas）を最高レベルまで引き上げる必要があり、弱点のあるエリアが一つでもあれば昇格できない（TPI Nextは全エリアの均一な成長を求めていない）",
            "TPI Nextでは、ビジネス目標に合わせて優先すべきキーエリアを選択できるため、すべてのキーエリアをレベルアップさせる必要はなく、モデルが推奨する特定のチェックポイント群をクリアすればよい",
            "レベルBへの移行には、テストツールの導入が必須条件となっており、自動化率が50%を超えていない組織はレベルAに留め置かれる（ツールは手段であり、レベル定義の必須条件ではない）",
            "レベルの判定は外部監査員のみが可能であるため、自社でどれだけ改善活動を行っても、高額な費用を払って監査を受けない限りレベルアップは認められない（自己診断が可能）"
        ],
        "answer": [
            "TPI Nextでは、ビジネス目標に合わせて優先すべきキーエリアを選択できるため、すべてのキーエリアをレベルアップさせる必要はなく、モデルが推奨する特定のチェックポイント群をクリアすればよい"
        ],
        "explanation": "【解説】\nTPI Nextは柔軟なモデルです。CMMIのように「全エリアの達成」を厳格に求めるのではなく、成熟度マトリクスに基づき、段階的に必要なチェックポイントをクリアしていくアプローチをとります。",
        "tags": ["第3章", "一般", "シナリオ", "K3"]
    }
]

# 2. 第1章 一般 (ch1_general_vol117.json)
q1_gen = [
    {
        "id": "Q1-GEN-V117-01",
        "chapter": "第1章",
        "level": "K3",
        "category": "一般",
        "style": "シナリオ",
        "type": "単一選択",
        "question": "【適用】クラシフィケーションツリー法（CTM）の活用。\n複雑なパラメータを持つシステムのテスト設計において、組み合わせ爆発を防ぎつつ、意味のあるテストケースを視覚的に整理したい。\nCTMを採用する最大のメリットと手順として正しいものはどれか。",
        "options": [
            "パラメータをツリー構造（分類木）で階層的に整理し、互いに排他的なクラス（値）を定義することで、テストケースの組み合わせを視覚的に選択・最小化できる",
            "決定表（デシジョンテーブル）と同様に、すべての条件の全組み合わせ（2のn乗）を機械的に生成するための手法であり、組み合わせの削減効果はない（CTMは削減と整理が目的）",
            "マインドマップを使ってブレインストーミングを行い、思いついたテストケースをランダムに枝に追加していく手法であり、厳密な構造化は不要である（CTMは厳密な分割定義が必要）",
            "AIが自動的にテストケースを生成するツールの名称であり、人間が設計を行う必要がなくなる（CTMは人間が設計する技法）"
        ],
        "answer": [
            "パラメータをツリー構造（分類木）で階層的に整理し、互いに排他的なクラス（値）を定義することで、テストケースの組み合わせを視覚的に選択・最小化できる"
        ],
        "explanation": "【解説】\nクラシフィケーションツリー法（CTM）の特徴は「視覚的なモデリング」です。パラメータ（分類）と値（クラス）をツリー状に整理し、必要な組み合わせだけを選択表でマークすることで、効率的なテスト設計を可能にします。",
        "tags": ["第1章", "一般", "シナリオ", "K3"]
    }
]

# 3. 第2章 一般 (ch2_general_vol117.json)
q2_gen = [
    {
        "id": "Q2-GEN-V117-01",
        "chapter": "第2章",
        "level": "K4",
        "category": "一般",
        "style": "シナリオ",
        "type": "単一選択",
        "question": "【分析】サイクロマティック複雑度（循環的複雑度）とテスト工数。\nあるモジュールのソースコードを解析したところ、サイクロマティック複雑度が「50」という極めて高い値を示した。\nこの指標から読み取れるリスクと、テストマネージャが取るべきアクションはどれか。",
        "options": [
            "複雑度が50ということは50行のコードであることを示しており、規模が小さいためテスト工数は少なくて済むと判断する（複雑度と行数は異なる）",
            "分岐やループが非常に多く、制御フローが複雑怪奇であることを示しているため、バグ混入率が高いと推測し、重点的な単体テスト（C1/C2網羅）とリファクタリングを推奨する",
            "複雑度が高いほどプログラムが高機能で優秀であることを示しているため、このモジュールは品質が高いと判断し、テストを省略する（複雑度はバグの温床）",
            "サイクロマティック複雑度はブラックボックステストの指標であるため、ソースコードの構造とは無関係であり、画面項目の多さを示している（ホワイトボックスの指標である）"
        ],
        "answer": [
            "分岐やループが非常に多く、制御フローが複雑怪奇であることを示しているため、バグ混入率が高いと推測し、重点的な単体テスト（C1/C2網羅）とリファクタリングを推奨する"
        ],
        "explanation": "【解説】\nサイクロマティック複雑度は「線形独立なパスの数」を示します。一般に10以下が推奨され、50は極めて危険なスパゲッティコードの可能性が高いです。徹底的なテストとリファクタリングが必要です。",
        "tags": ["第2章", "一般", "シナリオ", "K4"]
    }
]

# 4. 第1章 AWS (ch1_aws_vol117.json)
q1_aws = [
    {
        "id": "Q1-AWS-V117-01",
        "chapter": "第1章",
        "level": "K3",
        "category": "AWS",
        "style": "シナリオ",
        "type": "単一選択",
        "question": "【適用】コンテナイメージの脆弱性スキャン（ECR）。\nCI/CDパイプラインにおいて、Amazon ECRにプッシュされたDockerイメージに「Critical（緊急）」レベルの脆弱性が含まれていた場合、デプロイを自動的にブロックしたい。\nこれを実現する構成はどれか。",
        "options": [
            "ECRの「プッシュ時のスキャン（Scan on push）」を有効にし、スキャン結果がEventBridgeに通知されたら、Lambda等を起動してCodePipelineの承認ステージを「拒否」にするワークフローを組む",
            "ECRの設定画面で「脆弱性があるイメージのプルを拒否」というチェックボックスをオンにするだけで、自動的にブロックされる（そのような単純な設定項目はない）",
            "Dockerイメージの中にアンチウイルスソフトをインストールしておき、ウイルスが見つかったらコンテナが自爆するようにスクリプトを書く（コンテナの起動前に対処すべき）",
            "開発者のPCに脆弱性スキャンツールを入れ、スキャンしたという報告書をメールで送らない限り、ECRへのプッシュ権限を与えない運用にする（人的運用は漏れが発生する）"
        ],
        "answer": [
            "ECRの「プッシュ時のスキャン（Scan on push）」を有効にし、スキャン結果がEventBridgeに通知されたら、Lambda等を起動してCodePipelineの承認ステージを「拒否」にするワークフローを組む"
        ],
        "explanation": "【解説】\nAWSでの脆弱性対応自動化は「EventBridge」が起点となります。ECRのスキャン完了イベントをトリガーに、パイプラインを停止させる仕組みを構築するのがベストプラクティスです。",
        "tags": ["第1章", "AWS", "シナリオ", "K3"]
    }
]

# 5. 第2章 金融 (ch2_finance_vol117.json)
q2_fin = [
    {
        "id": "Q2-FIN-V117-01",
        "chapter": "第2章",
        "level": "K4",
        "category": "金融",
        "style": "シナリオ",
        "type": "単一選択",
        "question": "【分析】デリバティブ商品の時価評価（Mark-to-Market）テスト。\n複雑な金融派生商品の現在価値を計算するシステムにおいて、計算結果の正当性を検証したい。\nブラックボックステストのアプローチとして、最も信頼性が高い比較検証方法はどれか。",
        "options": [
            "開発者が作成したExcelシートの計算式と、システムの実装ロジックを見比べ、数式が同じであれば正しいとみなす（Excel側の数式ミスや実装ミスを見抜けない）",
            "信頼できる第三者機関（ベンダーや情報ベンダー）の計算ツール、または既に稼働実績のある旧システムに同じ市場データ（金利、ボラティリティ等）を入力し、その算出結果と新システムの値を突合する",
            "計算結果がマイナスにならなければ正常とみなし、値の正確さまでは追求しない（デリバティブはマイナス評価もあり得るし、精度の検証になっていない）",
            "ランダムな数値を入力して計算エラー（例外）が発生しないことだけを確認し、計算結果の数字自体は検証対象外とする（機能テストとしては不十分）"
        ],
        "answer": [
            "信頼できる第三者機関（ベンダーや情報ベンダー）の計算ツール、または既に稼働実績のある旧システムに同じ市場データ（金利、ボラティリティ等）を入力し、その算出結果と新システムの値を突合する"
        ],
        "explanation": "【解説】\n金融工学を駆使した計算ロジックのテストでは、「実績のある別の計算機（Benchmark）」との比較が最も有効です。これを「並行テスト」や「ベンチマークテスト」と呼びます。",
        "tags": ["第2章", "金融", "シナリオ", "K4"]
    }
]

# ==========================================
# ファイル生成 & Index更新処理
# ==========================================
files_content = {
    "ch3_general_vol117.json": q3_gen,
    "ch1_general_vol117.json": q1_gen,
    "ch2_general_vol117.json": q2_gen,
    "ch1_aws_vol117.json": q1_aws,
    "ch2_finance_vol117.json": q2_fin
}

def generate_and_update():
    # 1. ファイル生成
    new_entries = []
    
    print("--- ファイル生成開始 ---")
    for filename, content in files_content.items():
        file_path = os.path.join(OUTPUT_DIR, filename)
        try:
            with open(file_path, 'w', encoding='utf-8') as f:
                json.dump(content, f, ensure_ascii=False, indent=2)
            print(f"作成: {filename}")
            
            # メタデータ抽出（Index用）
            first_q = content[0]
            entry = {
                "path": f"questions/{filename}", # アプリの仕様に合わせたパス
                "chapter": first_q.get("chapter", "不明"),
                "category": first_q.get("category", "不明"),
                "klevel": first_q.get("level", "K2"),
                "qCount": len(content)
            }
            new_entries.append(entry)
            
        except Exception as e:
            print(f"エラー作成中 {filename}: {e}")

    # 2. Index更新
    print("\n--- Index更新開始 ---")
    if not os.path.exists(INDEX_FILE):
        print(f"エラー: {INDEX_FILE} が見つかりません。")
        return

    try:
        with open(INDEX_FILE, 'r', encoding='utf-8') as f:
            index_data = json.load(f)
        
        existing_paths = {item.get("path") for item in index_data.get("chunks", [])}
        added_count = 0
        
        for entry in new_entries:
            if entry["path"] not in existing_paths:
                index_data["chunks"].append(entry)
                print(f"Index追加: {entry['path']}")
                added_count += 1
            else:
                print(f"Indexスキップ（登録済）: {entry['path']}")
        
        if added_count > 0:
            with open(INDEX_FILE, 'w', encoding='utf-8') as f:
                json.dump(index_data, f, ensure_ascii=False, indent=2)
            print(f"Index保存完了: {added_count}件追加")
        else:
            print("Index更新なし")

    except Exception as e:
        print(f"Index更新エラー: {e}")

if __name__ == "__main__":
    generate_and_update()