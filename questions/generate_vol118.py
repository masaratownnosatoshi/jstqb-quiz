import json
import os

# 保存先ディレクトリ
OUTPUT_DIR = "."
INDEX_FILE = "index.json"

# ==========================================
# Vol.118 新規問題データ定義
# ==========================================

# 1. 第3章 一般 (ch3_general_vol118.json)
q3_gen = [
    {
        "id": "Q3-GEN-V118-01",
        "chapter": "第3章",
        "level": "K3",
        "category": "一般",
        "style": "シナリオ",
        "type": "単一選択",
        "question": "【適用】テスト見積もり技法（ワイドバンド・デルファイ法）。\n新規プロジェクトのテスト工数を見積もるために、数名の専門家を集めて見積もり会議を開催することにした。\n権威ある人物（シニアマネージャ等）の意見に全員が引きずられる「バンドワゴン効果」を防ぐための、デルファイ法の正しい運用手順はどれか。",
        "options": [
            "最初の投票は無記名で行い、全員の数値と極端な値の理由を共有した後、議論を経て再度投票を行うプロセスを、数値が収束するまで繰り返す",
            "最も経験のあるリーダーが最初に自分の見積もり値を発表し、他のメンバーがそれを参考に修正案を出すことで、効率的に合意形成を図る（バイアスの原因になる）",
            "全員で一斉に数値を叫び、最も声が大きかった人の数値を採用することで、自信のある人の意見を尊重する（科学的根拠がない）",
            "専門家同士は一切会話をせず、メールで送られてきた数値を平均するだけで終了とし、フィードバックや再投票の機会は設けない（単純平均であり、デルファイ法の合意形成プロセスではない）"
        ],
        "answer": [
            "最初の投票は無記名で行い、全員の数値と極端な値の理由を共有した後、議論を経て再度投票を行うプロセスを、数値が収束するまで繰り返す"
        ],
        "explanation": "【解説】\nワイドバンド・デルファイ法の特徴は「無記名投票」と「フィードバックによる反復」です。誰がどの数字を出したか伏せることで、権威バイアスを排除します。",
        "tags": ["第3章", "一般", "シナリオ", "K3"]
    }
]

# 2. 第1章 一般 (ch1_general_vol118.json)
q1_gen = [
    {
        "id": "Q1-GEN-V118-01",
        "chapter": "第1章",
        "level": "K3",
        "category": "一般",
        "style": "シナリオ",
        "type": "単一選択",
        "question": "【適用】テストの心理学（確証バイアス）。\n開発者が自分で書いたコードの単体テストを行う際、「正常に動作すること」を確認するテストケースばかりを作ってしまい、バグを見つけるための意地悪なテスト（異常系）が不足しがちである。\nこの心理的傾向（確証バイアス）を緩和するための対策として、最も効果的なアプローチはどれか。",
        "options": [
            "開発者に対し、バグを見つけることは恥ずかしいことだと教育し、完璧なコードを書くようプレッシャーをかける（心理的安全性を破壊し、隠蔽を助長する）",
            "開発者とは異なる視点を持つ「独立したテスト担当者」や「別の開発者（クロスチェック）」にテストケースのレビューや追加作成を依頼する",
            "正常系のテストさえ通ればリリース可能とみなし、異常系のテストは運用開始後にユーザーに見つけてもらうことにする（品質保証の放棄）",
            "開発者にテストの自動化ツールを与えれば、ツールが勝手に異常系を考えてくれると期待して、人間によるテスト設計をやめさせる（ツールは指示されたことしかしない）"
        ],
        "answer": [
            "開発者とは異なる視点を持つ「独立したテスト担当者」や「別の開発者（クロスチェック）」にテストケースのレビューや追加作成を依頼する"
        ],
        "explanation": "【解説】\n自分の作ったものが正しいと思いたい「確証バイアス」は、本人だけでは回避困難です。「独立性（Independence）」を持った第三者の介入が特効薬となります。",
        "tags": ["第1章", "一般", "シナリオ", "K3"]
    }
]

# 3. 第2章 一般 (ch2_general_vol118.json)
q2_gen = [
    {
        "id": "Q2-GEN-V118-01",
        "chapter": "第2章",
        "level": "K3",
        "category": "一般",
        "style": "シナリオ",
        "type": "単一選択",
        "question": "【適用】統合テストのアプローチ（トップダウン vs ボトムアップ）。\n上位のユーザーインターフェース（UI）や制御モジュールは完成しているが、下位のデータベースアクセス層や通信モジュールが未完成である。\nこの状態で、完成している上位モジュールのロジックや画面遷移を先行してテストしたい。\n必要となるテストスタブ/ドライバの組み合わせと、採用すべきアプローチはどれか。",
        "options": [
            "未完成の下位モジュールの代わりになる「スタブ（Stub）」を作成し、上位から下位を呼び出す「トップダウンアプローチ」を採用する",
            "未完成の下位モジュールを呼び出すための「ドライバ（Driver）」を作成し、下位から順にテストする「ボトムアップアプローチ」を採用する（上位はあるのでドライバは不要）",
            "すべてのモジュールが揃うまでテストを待機し、一気に結合する「ビッグバンアプローチ」を採用する（早期発見のメリットがない）",
            "未完成の部分は本番環境のサービスに直接接続して代用することで、スタブ作成の手間を省く「サンドイッチアプローチ」を採用する（開発中に本番接続は危険）"
        ],
        "answer": [
            "未完成の下位モジュールの代わりになる「スタブ（Stub）」を作成し、上位から下位を呼び出す「トップダウンアプローチ」を採用する"
        ],
        "explanation": "【解説】\n「上位（呼ぶ側）」があって「下位（呼ばれる側）」がない場合は、下位の偽物である「スタブ」を使ったトップダウンアプローチが適切です。",
        "tags": ["第2章", "一般", "シナリオ", "K3"]
    }
]

# 4. 第1章 AWS (ch1_aws_vol118.json)
q1_aws = [
    {
        "id": "Q1-AWS-V118-01",
        "chapter": "第1章",
        "level": "K3",
        "category": "AWS",
        "style": "シナリオ",
        "type": "単一選択",
        "question": "【適用】EC2からのセキュアなS3アクセス。\nEC2インスタンス上で動作するアプリケーションから、プライベートなS3バケットにファイルをアップロードしたい。\nアクセスキー（AK/SK）をコードに埋め込まず、最もセキュアに権限を付与する方法はどれか。",
        "options": [
            "IAMユーザーを作成してアクセスキーを発行し、そのキーをOSの環境変数に設定してアプリケーションから読み込ませる（キー漏洩のリスクが残る）",
            "S3への書き込み権限を持つ「IAMロール」を作成してEC2インスタンスにアタッチし、SDKやCLIが自動的に一時的な認証情報を取得する仕組みを利用する",
            "S3バケットを「パブリック書き込み許可」設定に変更し、認証なしで誰でもアップロードできるようにする（セキュリティ事故そのもの）",
            "AWS Systems Manager Parameter Storeにアクセスキーを保存し、アプリ起動時に取得する（キーのローテーション管理が必要になり、ロールより劣る）"
        ],
        "answer": [
            "S3への書き込み権限を持つ「IAMロール」を作成してEC2インスタンスにアタッチし、SDKやCLIが自動的に一時的な認証情報を取得する仕組みを利用する"
        ],
        "explanation": "【解説】\nAWSリソース（EC2等）からのアクセスには、永続的なクレデンシャル（アクセスキー）ではなく、「IAMロール」を使用するのがベストプラクティスです。",
        "tags": ["第1章", "AWS", "シナリオ", "K3"]
    }
]

# 5. 第2章 金融 (ch2_finance_vol118.json)
q2_fin = [
    {
        "id": "Q2-FIN-V118-01",
        "chapter": "第2章",
        "level": "K4",
        "category": "金融",
        "style": "シナリオ",
        "type": "単一選択",
        "question": "【分析】外国送金（SWIFT）の手数料負担区分。\n海外送金機能のテストにおいて、手数料負担区分（Charge Bearer）の仕様通りに送金金額と着金金額が計算されるか検証したい。\n「送金人が手数料を全額負担する（受取人は満額受け取る）」場合のSWIFTコード指定と、検証ポイントの組み合わせとして正しいものはどれか。",
        "options": [
            "コード「SHA（Shared）」を指定し、送金手数料は送金人が払い、中継銀行の手数料は送金金額から差し引かれることを確認する（受取額が減る）",
            "コード「BEN（Beneficiary）」を指定し、すべての手数料が送金金額から差し引かれ、受取人には手数料を引いた残額が入金されることを確認する（受取人負担）",
            "コード「OUR（Remitter）」を指定し、送金手数料および関係銀行手数料が送金人に別途請求され、送金依頼額がそのまま減額されずに着金することを確認する",
            "コード「FIX（Fixed）」を指定し、手数料が一律1000円になることを確認する（SWIFTにFIXという区分はない）"
        ],
        "answer": [
            "コード「OUR（Remitter）」を指定し、送金手数料および関係銀行手数料が送金人に別途請求され、送金依頼額がそのまま減額されずに着金することを確認する"
        ],
        "explanation": "【解説】\n海外送金のテストでは手数料負担区分が重要です。\nOUR：送金人負担（満額着金）\nSHA：分担（送金側のみ送金人、他は受取人）\nBEN：受取人負担（全額差し引き）",
        "tags": ["第2章", "金融", "シナリオ", "K4"]
    }
]

# ==========================================
# ファイル生成 & Index更新処理
# ==========================================
files_content = {
    "ch3_general_vol118.json": q3_gen,
    "ch1_general_vol118.json": q1_gen,
    "ch2_general_vol118.json": q2_gen,
    "ch1_aws_vol118.json": q1_aws,
    "ch2_finance_vol118.json": q2_fin
}

def generate_and_update():
    # 1. ファイル生成
    new_entries = []
    
    print("--- ファイル生成開始 ---")
    for filename, content in files_content.items():
        file_path = os.path.join(OUTPUT_DIR, filename)
        try:
            with open(file_path, 'w', encoding='utf-8') as f:
                json.dump(content, f, ensure_ascii=False, indent=2)
            print(f"作成: {filename}")
            
            # メタデータ抽出（Index用）
            first_q = content[0]
            entry = {
                "path": f"questions/{filename}", # アプリの仕様に合わせたパス
                "chapter": first_q.get("chapter", "不明"),
                "category": first_q.get("category", "不明"),
                "klevel": first_q.get("level", "K2"),
                "qCount": len(content)
            }
            new_entries.append(entry)
            
        except Exception as e:
            print(f"エラー作成中 {filename}: {e}")

    # 2. Index更新
    print("\n--- Index更新開始 ---")
    if not os.path.exists(INDEX_FILE):
        print(f"エラー: {INDEX_FILE} が見つかりません。")
        return

    try:
        with open(INDEX_FILE, 'r', encoding='utf-8') as f:
            index_data = json.load(f)
        
        existing_paths = {item.get("path") for item in index_data.get("chunks", [])}
        added_count = 0
        
        for entry in new_entries:
            if entry["path"] not in existing_paths:
                index_data["chunks"].append(entry)
                print(f"Index追加: {entry['path']}")
                added_count += 1
            else:
                print(f"Indexスキップ（登録済）: {entry['path']}")
        
        if added_count > 0:
            with open(INDEX_FILE, 'w', encoding='utf-8') as f:
                json.dump(index_data, f, ensure_ascii=False, indent=2)
            print(f"Index保存完了: {added_count}件追加")
        else:
            print("Index更新なし")

    except Exception as e:
        print(f"Index更新エラー: {e}")

if __name__ == "__main__":
    generate_and_update()