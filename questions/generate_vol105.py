import json
import os

# 保存先ディレクトリ
OUTPUT_DIR = "."
INDEX_FILE = "index.json"

# ==========================================
# Vol.105 新規問題データ定義
# ==========================================

# 1. 第3章 一般 (ch3_general_vol105.json)
q3_gen = [
    {
        "id": "Q3-GEN-V105-01",
        "chapter": "第3章",
        "level": "K3",
        "category": "一般",
        "style": "シナリオ",
        "type": "単一選択",
        "question": "【適用】テスト自動化エンジニアのキャリアパス設計。\n手動テストの経験は豊富だがプログラミング経験がないメンバーを、自動化エンジニアとして育成したい。\n最初のアサインメントとして最も適切で、かつ学習効果が高いタスクはどれか。",
        "options": [
            "高度なCI/CDパイプラインの構築を任せ、DevOpsの全体像を理解させることで、自動化の意義を学ばせる（難易度が高すぎて挫折するリスク）",
            "既存の「キーワード駆動フレームワーク」を使用したテストケースのデータ入力や、簡単なスクリプトのメンテナンスから始めさせ、徐々にコードに触れる機会を増やす",
            "自動化ツールをゼロから選定させ、比較検討レポートを作成させることで、ツールの特性を深く理解させる（経験がない状態での選定は困難）",
            "プログラミング言語の教本を渡し、独学で文法をマスターするまで業務には参加させない（実践的なスキルが身につかない）"
        ],
        "answer": [
            "既存の「キーワード駆動フレームワーク」を使用したテストケースのデータ入力や、簡単なスクリプトのメンテナンスから始めさせ、徐々にコードに触れる機会を増やす"
        ],
        "explanation": "【解説】\n未経験者の育成には「既存資産の活用」から入るのが定石です。成功体験を積み重ねながら、徐々に技術的な難易度を上げていくステップアップが必要です。",
        "tags": ["第3章", "一般", "シナリオ", "K3"]
    }
]

# 2. 第1章 一般 (ch1_general_vol105.json)
q1_gen = [
    {
        "id": "Q1-GEN-V105-01",
        "chapter": "第1章",
        "level": "K4",
        "category": "一般",
        "style": "シナリオ",
        "type": "単一選択",
        "question": "【分析】テストプロセスのボトルネック分析。\n「テスト実行」フェーズで進捗が遅れている。原因を調査したところ、テスト環境のデータ不整合によりテストが中断し、データ修正待ち（Wait）の時間が頻発していることが分かった。\nこのボトルネックを解消するための根本対策はどれか。",
        "options": [
            "テスターを増員して待ち時間を埋めるために並列で作業を進め、データが使える環境を探しながらテストを行う（非効率で根本解決にならない）",
            "テストデータ管理（TDM）プロセスを見直し、テスト実行前に整合性の取れたデータを自動でセットアップ（リセット）する仕組みを導入して、待ち時間をゼロにする",
            "開発チームにデータ修正を依頼するのではなく、テスター自身がSQLを書いてデータを修正するように教育し、自律的に解決させる（テスターの負荷増大とデータ破壊リスク）",
            "テスト実行の進捗遅れを取り戻すために、データ不整合が発生しやすい複雑なシナリオのテストをスキップし、簡単なテストだけを優先して消化する（品質リスクの増大）"
        ],
        "answer": [
            "テストデータ管理（TDM）プロセスを見直し、テスト実行前に整合性の取れたデータを自動でセットアップ（リセット）する仕組みを導入して、待ち時間をゼロにする"
        ],
        "explanation": "【解説】\n「待ち時間」の削減はプロセス改善の基本です。TDM（Test Data Management）の自動化や整備が、環境起因のボトルネックに対する根本治療となります。",
        "tags": ["第1章", "一般", "シナリオ", "K4"]
    }
]

# 3. 第2章 一般 (ch2_general_vol105.json)
q2_gen = [
    {
        "id": "Q2-GEN-V105-01",
        "chapter": "第2章",
        "level": "K3",
        "category": "一般",
        "style": "シナリオ",
        "type": "単一選択",
        "question": "【適用】探索的テストのチャーター設計。\n新機能「商品検索」に対する探索的テストを実施したい。テスターの創造性を引き出しつつ、テストの方向性を制御するための「テストチャーター（指針）」の記述として最も適切なものはどれか。",
        "options": [
            "「検索機能をテストする」とだけ記述し、テスターに全ての判断を委ねる（自由すぎて目的がブレる可能性がある）",
            "「ユーザーが商品を検索し、カートに入れるまでの流れを確認する。特に、検索条件の組み合わせによる絞り込み結果の正確性と、検索結果ゼロ件時の挙動に注目して探索せよ」",
            "詳細なテスト手順書（Step-by-Step）を作成し、テスターにはその通りに操作することだけを求め、手順外の操作は禁止する（これはスクリプトテストであり、探索的テストではない）",
            "「バグを10個見つけるまで終わらないこと」というノルマを設定し、テスターに対してプレッシャーを与えることで集中力を高める（質の低いバグ報告を誘発する）"
        ],
        "answer": [
            "「ユーザーが商品を検索し、カートに入れるまでの流れを確認する。特に、検索条件の組み合わせによる絞り込み結果の正確性と、検索結果ゼロ件時の挙動に注目して探索せよ」"
        ],
        "explanation": "【解説】\n優れたチャーターは「ミッション（目的）」と「フォーカス（注目点）」を明確にしつつ、具体的な操作方法はテスターの裁量に任せるものです。",
        "tags": ["第2章", "一般", "シナリオ", "K3"]
    }
]

# 4. 第1章 AWS (ch1_aws_vol105.json)
q1_aws = [
    {
        "id": "Q1-AWS-V105-01",
        "chapter": "第1章",
        "level": "K3",
        "category": "AWS",
        "style": "シナリオ",
        "type": "単一選択",
        "question": "【適用】Blue/Greenデプロイメントのテスト戦略。\nECS（コンテナ）環境でBlue/Greenデプロイを採用している。新バージョン（Green）への切り替え前に実施すべきテストとして、最も適切なものはどれか。",
        "options": [
            "Green環境に対して、本番トラフィックの1%だけを流す「カナリアリリース」を行い、エラー率やレイテンシを監視して問題がないことを確認してから、徐々にトラフィックを増やす",
            "Green環境は本番用DBに接続されているため、データの整合性を壊すリスクがあるテスト（更新系）は一切行わず、参照系の画面確認だけを軽く済ませる（リスクの見落とし）",
            "Green環境に対して、社内のテストチームから負荷テストツールで大量のリクエストを送信し、本番環境の限界性能を超えるまで負荷をかけ続ける（本番ネットワークへの影響リスク）",
            "Blue環境（現行）をシャットダウンしてからGreen環境を起動し、ダウンタイムが発生している間に急いで動作確認を行う（無停止デプロイのメリットを活かせていない）"
        ],
        "answer": [
            "Green環境に対して、本番トラフィックの1%だけを流す「カナリアリリース」を行い、エラー率やレイテンシを監視して問題がないことを確認してから、徐々にトラフィックを増やす"
        ],
        "explanation": "【解説】\nBlue/Greenやカナリアリリースでは、実トラフィックの一部を用いた検証が可能です。これにより、テスト環境では再現できない本番特有の問題を、影響を最小限に抑えつつ検出できます。",
        "tags": ["第1章", "AWS", "シナリオ", "K3"]
    }
]

# 5. 第2章 金融 (ch2_finance_vol105.json)
q2_fin = [
    {
        "id": "Q2-FIN-V105-01",
        "chapter": "第2章",
        "level": "K3",
        "category": "金融",
        "style": "シナリオ",
        "type": "単一選択",
        "question": "【適用】アンチマネーロンダリング（AML）システムのテスト。\n「疑わしい取引」を検知するルールのテストを行いたい。ルール：「同一口座に対して、1時間以内に3回以上の海外送金が行われた場合、アラートを出す」。\nこのルールを検証するためのテストデータセットとして、必要十分な組み合わせはどれか。",
        "options": [
            "1時間以内に2回送金するケース（非検知）と、4回送金するケース（検知）のみを作成する（境界値の確認が不足している）",
            "1時間以内に2回送金（非検知）、3回送金（検知）、4回送金（検知）のケースに加え、1時間1分かけて3回送金（非検知）するケースを作成し、回数と時間の境界値を網羅する",
            "過去に実際に検知された本番データのみを使用し、新しいパターンや境界値についてはテストを行わない（既知のパターンしか検証できない）",
            "送金金額が1億円以上のケースのみをテストし、回数や時間間隔については考慮しない（ルールの条件と合致していない）"
        ],
        "answer": [
            "1時間以内に2回送金（非検知）、3回送金（検知）、4回送金（検知）のケースに加え、1時間1分かけて3回送金（非検知）するケースを作成し、回数と時間の境界値を網羅する"
        ],
        "explanation": "【解説】\nAMLルールのテストでは、「回数」と「時間窓（ウィンドウ）」の両方の境界値を検証する必要があります。「3回」と「1時間以内」の境界を狙うのがポイントです。",
        "tags": ["第2章", "金融", "シナリオ", "K3"]
    }
]

# ==========================================
# ファイル生成 & Index更新処理
# ==========================================
files_content = {
    "ch3_general_vol105.json": q3_gen,
    "ch1_general_vol105.json": q1_gen,
    "ch2_general_vol105.json": q2_gen,
    "ch1_aws_vol105.json": q1_aws,
    "ch2_finance_vol105.json": q2_fin
}

def generate_and_update():
    # 1. ファイル生成
    new_entries = []
    
    print("--- ファイル生成開始 ---")
    for filename, content in files_content.items():
        file_path = os.path.join(OUTPUT_DIR, filename)
        try:
            with open(file_path, 'w', encoding='utf-8') as f:
                json.dump(content, f, ensure_ascii=False, indent=2)
            print(f"作成: {filename}")
            
            # メタデータ抽出（Index用）
            first_q = content[0]
            entry = {
                "path": f"questions/{filename}", # アプリの仕様に合わせたパス
                "chapter": first_q.get("chapter", "不明"),
                "category": first_q.get("category", "不明"),
                "klevel": first_q.get("level", "K2"),
                "qCount": len(content)
            }
            new_entries.append(entry)
            
        except Exception as e:
            print(f"エラー作成中 {filename}: {e}")

    # 2. Index更新
    print("\n--- Index更新開始 ---")
    if not os.path.exists(INDEX_FILE):
        print(f"エラー: {INDEX_FILE} が見つかりません。")
        return

    try:
        with open(INDEX_FILE, 'r', encoding='utf-8') as f:
            index_data = json.load(f)
        
        existing_paths = {item.get("path") for item in index_data.get("chunks", [])}
        added_count = 0
        
        for entry in new_entries:
            if entry["path"] not in existing_paths:
                index_data["chunks"].append(entry)
                print(f"Index追加: {entry['path']}")
                added_count += 1
            else:
                print(f"Indexスキップ（登録済）: {entry['path']}")
        
        if added_count > 0:
            with open(INDEX_FILE, 'w', encoding='utf-8') as f:
                json.dump(index_data, f, ensure_ascii=False, indent=2)
            print(f"Index保存完了: {added_count}件追加")
        else:
            print("Index更新なし")

    except Exception as e:
        print(f"Index更新エラー: {e}")

if __name__ == "__main__":
    generate_and_update()