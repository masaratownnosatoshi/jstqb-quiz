import json
import os

# 保存先ディレクトリ
OUTPUT_DIR = "."
INDEX_FILE = "index.json"

# ==========================================
# Vol.106 新規問題データ定義
# ==========================================

# 1. 第3章 一般 (ch3_general_vol106.json)
q3_gen = [
    {
        "id": "Q3-GEN-V106-01",
        "chapter": "第3章",
        "level": "K4",
        "category": "一般",
        "style": "シナリオ",
        "type": "単一選択",
        "question": "【分析】テストチームのコンフリクト解消。\n開発チームとテストチームの間で「バグ修正の優先順位」に関する対立が絶えない。\nテスターは「全てのバグを直すべき」と主張し、開発者は「軽微なバグまで直している時間はない」と主張している。\nマネージャとして、この対立を建設的に解消するためのアプローチはどれか。",
        "options": [
            "開発者の主張を受け入れ、テスターに対しては「これからは軽微なバグは報告しなくてよい」と指示し、バグ報告の基準を引き上げる（品質リスクの見逃し）",
            "テスターの主張を支持し、開発者に対して「品質第一」のスローガンを掲げさせ、全てのバグを修正するまでリリースを許可しない権限を行使する（ビジネスゴールの阻害）",
            "「バグトリアージ会議」を定期開催し、ビジネスリスクやユーザー影響度に基づく共通の優先順位付け基準（Severity vs Priority）を策定・合意して運用する",
            "両チームのリーダーを交代させ、新しいリーダー同士でゼロから関係構築をやり直させる（組織的な混乱を招く）"
        ],
        "answer": [
            "「バグトリアージ会議」を定期開催し、ビジネスリスクやユーザー影響度に基づく共通の優先順位付け基準（Severity vs Priority）を策定・合意して運用する"
        ],
        "explanation": "【解説】\n対立の原因は「基準の不一致」です。トリアージ会議を通じて、ビジネス価値に基づいた共通の物差し（優先度基準）を作ることが解決策です。",
        "tags": ["第3章", "一般", "シナリオ", "K4"]
    }
]

# 2. 第1章 一般 (ch1_general_vol106.json)
q1_gen = [
    {
        "id": "Q1-GEN-V106-01",
        "chapter": "第1章",
        "level": "K3",
        "category": "一般",
        "style": "シナリオ",
        "type": "単一選択",
        "question": "【適用】テスト終了基準の「条件付き合格」。\nテスト終了予定日を迎えたが、重要度「中」のバグが数件残っている。\nしかし、ビジネス側の要望でリリース日は絶対に動かせない。\nテストマネージャとして提案すべき現実的な落とし穴のない進め方はどれか。",
        "options": [
            "残存バグのステータスを全て「修正済み」に改ざんし、形式的に終了基準を満たしたことにしてリリースを強行する（コンプライアンス違反）",
            "残存バグのリスク（発生頻度×影響度）を評価し、ビジネスオーナーに「既知の不具合（Known Issues）」としてのリスク受容と、運用での回避策を提示して承認を得る",
            "リリース日を死守するために、残っているバグ修正は諦め、その代わりに次回のアップデートで必ず直すという口約束だけでリリースする（文書化された合意がない）",
            "開発チームに徹夜を命じ、リリース直前まで修正作業を続けさせ、テストなしで本番環境にパッチを当てる（新たなバグ混入リスクが最大化する）"
        ],
        "answer": [
            "残存バグのリスク（発生頻度×影響度）を評価し、ビジネスオーナーに「既知の不具合（Known Issues）」としてのリスク受容と、運用での回避策を提示して承認を得る"
        ],
        "explanation": "【解説】\n完全な状態でのリリースが不可能な場合、「リスク受容（Acceptance）」のプロセスを経ることが重要です。隠蔽や無謀な修正ではなく、リスクを可視化して合意形成を図ります。",
        "tags": ["第1章", "一般", "シナリオ", "K3"]
    }
]

# 3. 第2章 一般 (ch2_general_vol106.json)
q2_gen = [
    {
        "id": "Q2-GEN-V106-01",
        "chapter": "第2章",
        "level": "K3",
        "category": "一般",
        "style": "シナリオ",
        "type": "単一選択",
        "question": "【適用】ユーザビリティテストの実施タイミング。\n新しいECサイトのユーザビリティ（使いやすさ）を検証したい。\n手戻りを最小限に抑えつつ、最大の効果を得るためのテスト実施タイミングとして最も適切なものはどれか。",
        "options": [
            "開発が全て完了し、システムテストも終わったリリース直前に実施して、最終的な品質確認を行う（修正コストが最大化しており手遅れ）",
            "要件定義や設計段階の「プロトタイプ（画面モックアップ）」ができた時点で実施し、早期にユーザーフィードバックを得て設計に反映する",
            "リリース後に実際のユーザーに使ってもらい、問い合わせやクレームの内容から改善点を洗い出す（ユーザーの信頼を失うリスク）",
            "開発者が機能を実装した直後に、開発者自身が使いやすいかどうかを確認する（開発者バイアスがかかり、一般ユーザーの視点とは異なる）"
        ],
        "answer": [
            "要件定義や設計段階の「プロトタイプ（画面モックアップ）」ができた時点で実施し、早期にユーザーフィードバックを得て設計に反映する"
        ],
        "explanation": "【解説】\nユーザビリティの問題はUI/UXの設計に起因するため、コーディング前のプロトタイプ段階で検証するのが最もコスト効率が良い（シフトレフト）です。",
        "tags": ["第2章", "一般", "シナリオ", "K3"]
    }
]

# 4. 第1章 AWS (ch1_aws_vol106.json)
q1_aws = [
    {
        "id": "Q1-AWS-V106-01",
        "chapter": "第1章",
        "level": "K3",
        "category": "AWS",
        "style": "シナリオ",
        "type": "単一選択",
        "question": "【適用】災害対策（DR）訓練の実施。\n東京リージョンが全滅した場合に備えて、大阪リージョンへのフェイルオーバーを計画している。\nこのDR計画の実効性を検証するためのテストとして、最も推奨される方法はどれか。",
        "options": [
            "机上でDR手順書を読み合わせ、理論的に問題がないことを確認し、実機でのテストはコストがかかるため省略する（手順書の不備や想定外のエラーに気づけない）",
            "ゲームデー（GameDay）等の演習を実施し、実際に本番相当の環境で障害をシミュレートして切り替えを行い、RTO（目標復旧時間）内に復旧できるか実測する",
            "AWSサポートに問い合わせて、リージョン障害が発生した際に自動的に復旧してくれることを保証してもらう（責任共有モデルの誤解）",
            "本番環境のデータベースを大阪リージョンにコピーし、データが読めることだけを確認して、アプリケーションの切り替えテストは行わない（接続性やアプリ動作の検証不足）"
        ],
        "answer": [
            "ゲームデー（GameDay）等の演習を実施し、実際に本番相当の環境で障害をシミュレートして切り替えを行い、RTO（目標復旧時間）内に復旧できるか実測する"
        ],
        "explanation": "【解説】\nDR計画は「実際にやってみる」まで機能するかわかりません。GameDayのような実地訓練で手順とRTOを検証するのがベストプラクティスです。",
        "tags": ["第1章", "AWS", "シナリオ", "K3"]
    }
]

# 5. 第2章 金融 (ch2_finance_vol106.json)
q2_fin = [
    {
        "id": "Q2-FIN-V106-01",
        "chapter": "第2章",
        "level": "K3",
        "category": "金融",
        "style": "シナリオ",
        "type": "単一選択",
        "question": "【適用】バッチ処理の性能要件テスト。\n夜間バッチ処理において、「5時間以内に100万件のデータを処理終了すること」という非機能要件がある。\nこの要件を満たしているか確認するためのテストデータ準備と実施方法として適切なものはどれか。",
        "options": [
            "100件程度の少量のテストデータで実行し、その処理時間を1万倍して予測値を算出することで、本番規模のテストを代用する（データ量による非線形な性能劣化を検知できない）",
            "本番相当のデータ量（100万件）を用意し、本番と同等のスペックの環境でバッチを実行して、実際の処理時間が5時間以内に収まるかを計測する",
            "データ量に関わらず、CPU使用率が低いままであれば性能に問題ないと判断し、処理時間の計測は行わない（リソース使用率と処理時間は必ずしも比例しない）",
            "開発環境の低スペックなサーバーで実行し、処理が遅くても「本番なら速くなるはず」と楽観的に判断して合格とする（ハードウェア性能差の考慮不足）"
        ],
        "answer": [
            "本番相当のデータ量（100万件）を用意し、本番と同等のスペックの環境でバッチを実行して、実際の処理時間が5時間以内に収まるかを計測する"
        ],
        "explanation": "【解説】\nバッチ性能はデータ量に対して指数関数的に劣化することがあります（インデックス不足やメモリ溢れなど）。本番相当量での実測が必須です。",
        "tags": ["第2章", "金融", "シナリオ", "K3"]
    }
]

# ==========================================
# ファイル生成 & Index更新処理
# ==========================================
files_content = {
    "ch3_general_vol106.json": q3_gen,
    "ch1_general_vol106.json": q1_gen,
    "ch2_general_vol106.json": q2_gen,
    "ch1_aws_vol106.json": q1_aws,
    "ch2_finance_vol106.json": q2_fin
}

def generate_and_update():
    # 1. ファイル生成
    new_entries = []
    
    print("--- ファイル生成開始 ---")
    for filename, content in files_content.items():
        file_path = os.path.join(OUTPUT_DIR, filename)
        try:
            with open(file_path, 'w', encoding='utf-8') as f:
                json.dump(content, f, ensure_ascii=False, indent=2)
            print(f"作成: {filename}")
            
            # メタデータ抽出（Index用）
            first_q = content[0]
            entry = {
                "path": f"questions/{filename}", # アプリの仕様に合わせたパス
                "chapter": first_q.get("chapter", "不明"),
                "category": first_q.get("category", "不明"),
                "klevel": first_q.get("level", "K2"),
                "qCount": len(content)
            }
            new_entries.append(entry)
            
        except Exception as e:
            print(f"エラー作成中 {filename}: {e}")

    # 2. Index更新
    print("\n--- Index更新開始 ---")
    if not os.path.exists(INDEX_FILE):
        print(f"エラー: {INDEX_FILE} が見つかりません。")
        return

    try:
        with open(INDEX_FILE, 'r', encoding='utf-8') as f:
            index_data = json.load(f)
        
        existing_paths = {item.get("path") for item in index_data.get("chunks", [])}
        added_count = 0
        
        for entry in new_entries:
            if entry["path"] not in existing_paths:
                index_data["chunks"].append(entry)
                print(f"Index追加: {entry['path']}")
                added_count += 1
            else:
                print(f"Indexスキップ（登録済）: {entry['path']}")
        
        if added_count > 0:
            with open(INDEX_FILE, 'w', encoding='utf-8') as f:
                json.dump(index_data, f, ensure_ascii=False, indent=2)
            print(f"Index保存完了: {added_count}件追加")
        else:
            print("Index更新なし")

    except Exception as e:
        print(f"Index更新エラー: {e}")

if __name__ == "__main__":
    generate_and_update()